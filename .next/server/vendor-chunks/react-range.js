"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-range";
exports.ids = ["vendor-chunks/react-range"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-range/lib/Range.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/Range.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar React = __importStar(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-range/lib/utils.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/react-range/lib/types.js\");\nvar INCREASE_KEYS = [\"ArrowRight\", \"ArrowUp\", \"k\", \"PageUp\"];\nvar DECREASE_KEYS = [\"ArrowLeft\", \"ArrowDown\", \"j\", \"PageDown\"];\nvar Range = /** @class */ (function (_super) {\n    __extends(Range, _super);\n    function Range(props) {\n        var _this = _super.call(this, props) || this;\n        _this.trackRef = React.createRef();\n        _this.thumbRefs = [];\n        _this.state = {\n            draggedTrackPos: [-1, -1],\n            draggedThumbIndex: -1,\n            thumbZIndexes: new Array(_this.props.values.length).fill(0).map(function (t, i) { return i; }),\n            isChanged: false,\n            markOffsets: [],\n        };\n        _this.getOffsets = function () {\n            var _a = _this.props, direction = _a.direction, values = _a.values, min = _a.min, max = _a.max;\n            var trackElement = _this.trackRef.current;\n            if (!trackElement) {\n                console.warn(\"No track element found.\");\n                return [];\n            }\n            var trackRect = trackElement.getBoundingClientRect();\n            var trackPadding = (0, utils_1.getPaddingAndBorder)(trackElement);\n            return _this.getThumbs().map(function (thumb, index) {\n                var thumbOffsets = { x: 0, y: 0 };\n                var thumbRect = thumb.getBoundingClientRect();\n                var thumbMargins = (0, utils_1.getMargin)(thumb);\n                switch (direction) {\n                    case types_1.Direction.Right:\n                        thumbOffsets.x = (thumbMargins.left + trackPadding.left) * -1;\n                        thumbOffsets.y =\n                            ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;\n                        thumbOffsets.x +=\n                            trackRect.width * (0, utils_1.relativeValue)(values[index], min, max) -\n                                thumbRect.width / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Left:\n                        thumbOffsets.x = (thumbMargins.right + trackPadding.right) * -1;\n                        thumbOffsets.y =\n                            ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;\n                        thumbOffsets.x +=\n                            trackRect.width -\n                                trackRect.width * (0, utils_1.relativeValue)(values[index], min, max) -\n                                thumbRect.width / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Up:\n                        thumbOffsets.x =\n                            ((thumbRect.width - trackRect.width) / 2 +\n                                thumbMargins.left +\n                                trackPadding.left) *\n                                -1;\n                        thumbOffsets.y = -trackPadding.left;\n                        thumbOffsets.y +=\n                            trackRect.height -\n                                trackRect.height * (0, utils_1.relativeValue)(values[index], min, max) -\n                                thumbRect.height / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Down:\n                        thumbOffsets.x =\n                            ((thumbRect.width - trackRect.width) / 2 +\n                                thumbMargins.left +\n                                trackPadding.left) *\n                                -1;\n                        thumbOffsets.y = -trackPadding.left;\n                        thumbOffsets.y +=\n                            trackRect.height * (0, utils_1.relativeValue)(values[index], min, max) -\n                                thumbRect.height / 2;\n                        return thumbOffsets;\n                    default:\n                        return (0, utils_1.assertUnreachable)(direction);\n                }\n            });\n        };\n        _this.getThumbs = function () {\n            if (_this.trackRef && _this.trackRef.current) {\n                return Array.from(_this.trackRef.current.children).filter(function (el) {\n                    return el.hasAttribute(\"aria-valuenow\");\n                });\n            }\n            console.warn(\"No thumbs found in the track container. Did you forget to pass & spread the `props` param in renderTrack?\");\n            return [];\n        };\n        _this.getTargetIndex = function (e) {\n            return _this.getThumbs().findIndex(function (child) { return child === e.target || child.contains(e.target); });\n        };\n        _this.addTouchEvents = function (e) {\n            document.addEventListener(\"touchmove\", _this.schdOnTouchMove, {\n                passive: false,\n            });\n            document.addEventListener(\"touchend\", _this.schdOnEnd, {\n                passive: false,\n            });\n            document.addEventListener(\"touchcancel\", _this.schdOnEnd, {\n                passive: false,\n            });\n        };\n        _this.addMouseEvents = function (e) {\n            document.addEventListener(\"mousemove\", _this.schdOnMouseMove);\n            document.addEventListener(\"mouseup\", _this.schdOnEnd);\n        };\n        _this.onMouseDownTrack = function (e) {\n            var _a;\n            if (e.button !== 0 || (0, utils_1.isIOS)())\n                return;\n            e.persist();\n            e.preventDefault();\n            _this.addMouseEvents(e.nativeEvent);\n            if (_this.props.values.length > 1 && _this.props.draggableTrack) {\n                if (_this.thumbRefs.some(function (thumbRef) { var _a; return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target); }))\n                    return;\n                // handle dragging the whole track\n                _this.setState({\n                    draggedTrackPos: [e.clientX, e.clientY],\n                }, function () { return _this.onMove(e.clientX, e.clientY); });\n            }\n            else {\n                // get the index of the thumb that is closest to the place where the track is clicked\n                var draggedThumbIndex = (0, utils_1.getClosestThumbIndex)(_this.thumbRefs.map(function (t) { return t.current; }), e.clientX, e.clientY, _this.props.direction);\n                // move the thumb which is closest to the place where the track is clicked\n                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();\n                _this.setState({\n                    draggedThumbIndex: draggedThumbIndex,\n                }, function () { return _this.onMove(e.clientX, e.clientY); });\n            }\n        };\n        _this.onResize = function () {\n            (0, utils_1.translateThumbs)(_this.getThumbs(), _this.getOffsets(), _this.props.rtl);\n            _this.calculateMarkOffsets();\n        };\n        _this.onTouchStartTrack = function (e) {\n            var _a;\n            e.persist();\n            _this.addTouchEvents(e.nativeEvent);\n            if (_this.props.values.length > 1 && _this.props.draggableTrack) {\n                if (_this.thumbRefs.some(function (thumbRef) { var _a; return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target); }))\n                    return;\n                // handle dragging the whole track\n                _this.setState({\n                    draggedTrackPos: [e.touches[0].clientX, e.touches[0].clientY],\n                }, function () { return _this.onMove(e.touches[0].clientX, e.touches[0].clientY); });\n            }\n            else {\n                // get the index of the thumb that is closest to the place where the track is clicked\n                var draggedThumbIndex = (0, utils_1.getClosestThumbIndex)(_this.thumbRefs.map(function (t) { return t.current; }), e.touches[0].clientX, e.touches[0].clientY, _this.props.direction);\n                // move the thumb which is closest to the place where the track is clicked\n                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();\n                _this.setState({\n                    draggedThumbIndex: draggedThumbIndex,\n                }, function () { return _this.onMove(e.touches[0].clientX, e.touches[0].clientY); });\n            }\n        };\n        _this.onMouseOrTouchStart = function (e) {\n            if (_this.props.disabled)\n                return;\n            var isTouch = (0, utils_1.isTouchEvent)(e);\n            if (!isTouch && e.button !== 0)\n                return;\n            var index = _this.getTargetIndex(e);\n            if (index === -1)\n                return;\n            if (isTouch) {\n                _this.addTouchEvents(e);\n            }\n            else {\n                _this.addMouseEvents(e);\n            }\n            _this.setState({\n                draggedThumbIndex: index,\n                thumbZIndexes: _this.state.thumbZIndexes.map(function (t, i) {\n                    if (i === index) {\n                        return Math.max.apply(Math, _this.state.thumbZIndexes);\n                    }\n                    return t <= _this.state.thumbZIndexes[index] ? t : t - 1;\n                }),\n            });\n        };\n        _this.onMouseMove = function (e) {\n            e.preventDefault();\n            _this.onMove(e.clientX, e.clientY);\n        };\n        _this.onTouchMove = function (e) {\n            e.preventDefault();\n            _this.onMove(e.touches[0].clientX, e.touches[0].clientY);\n        };\n        _this.onKeyDown = function (e) {\n            var _a = _this.props, values = _a.values, onChange = _a.onChange, step = _a.step, rtl = _a.rtl, direction = _a.direction;\n            var isChanged = _this.state.isChanged;\n            var index = _this.getTargetIndex(e.nativeEvent);\n            var inverter = rtl || direction === types_1.Direction.Left || direction === types_1.Direction.Down\n                ? -1\n                : 1;\n            if (index === -1)\n                return;\n            if (INCREASE_KEYS.includes(e.key)) {\n                e.preventDefault();\n                _this.setState({\n                    draggedThumbIndex: index,\n                    isChanged: true,\n                });\n                onChange((0, utils_1.replaceAt)(values, index, _this.normalizeValue(values[index] + inverter * (e.key === \"PageUp\" ? step * 10 : step), index)));\n            }\n            else if (DECREASE_KEYS.includes(e.key)) {\n                e.preventDefault();\n                _this.setState({\n                    draggedThumbIndex: index,\n                    isChanged: true,\n                });\n                onChange((0, utils_1.replaceAt)(values, index, _this.normalizeValue(values[index] -\n                    inverter * (e.key === \"PageDown\" ? step * 10 : step), index)));\n            }\n            else if (e.key === \"Tab\") {\n                _this.setState({ draggedThumbIndex: -1 }, function () {\n                    // If key pressed when thumb was moving, fire onFinalChange\n                    if (isChanged) {\n                        _this.fireOnFinalChange();\n                    }\n                });\n            }\n            else {\n                if (isChanged) {\n                    _this.fireOnFinalChange();\n                }\n            }\n        };\n        _this.onKeyUp = function (e) {\n            var isChanged = _this.state.isChanged;\n            _this.setState({\n                draggedThumbIndex: -1,\n            }, function () {\n                if (isChanged) {\n                    _this.fireOnFinalChange();\n                }\n            });\n        };\n        _this.onMove = function (clientX, clientY) {\n            var _a = _this.state, draggedThumbIndex = _a.draggedThumbIndex, draggedTrackPos = _a.draggedTrackPos;\n            var _b = _this.props, direction = _b.direction, min = _b.min, max = _b.max, onChange = _b.onChange, values = _b.values, step = _b.step, rtl = _b.rtl;\n            if (draggedThumbIndex === -1 &&\n                draggedTrackPos[0] === -1 &&\n                draggedTrackPos[1] === -1)\n                return null;\n            var trackElement = _this.trackRef.current;\n            // If component was closed down prematurely, A last onMove could be triggered based on requestAnimationFrame()\n            if (!trackElement)\n                return null;\n            var trackRect = trackElement.getBoundingClientRect();\n            var trackLength = (0, utils_1.isVertical)(direction)\n                ? trackRect.height\n                : trackRect.width;\n            if (draggedTrackPos[0] !== -1 && draggedTrackPos[1] !== -1) {\n                // calculate how much it moved since the last update\n                var dX = clientX - draggedTrackPos[0];\n                var dY = clientY - draggedTrackPos[1];\n                // calculate the delta of the value\n                var deltaValue = 0;\n                switch (direction) {\n                    case types_1.Direction.Right:\n                    case types_1.Direction.Left:\n                        deltaValue = (dX / trackLength) * (max - min);\n                        break;\n                    case types_1.Direction.Down:\n                    case types_1.Direction.Up:\n                        deltaValue = (dY / trackLength) * (max - min);\n                        break;\n                    default:\n                        (0, utils_1.assertUnreachable)(direction);\n                }\n                // invert for RTL\n                if (rtl) {\n                    deltaValue *= -1;\n                }\n                if (Math.abs(deltaValue) >= step / 2) {\n                    // adjust delta so it fits into the range\n                    for (var i = 0; i < _this.thumbRefs.length; i++) {\n                        if ((values[i] === max && Math.sign(deltaValue) === 1) ||\n                            (values[i] === min && Math.sign(deltaValue) === -1))\n                            return;\n                        var thumbValue = values[i] + deltaValue;\n                        if (thumbValue > max)\n                            deltaValue = max - values[i];\n                        else if (thumbValue < min)\n                            deltaValue = min - values[i];\n                    }\n                    // add the delta to each thumb\n                    var newValues = values.slice(0);\n                    for (var i = 0; i < _this.thumbRefs.length; i++) {\n                        newValues = (0, utils_1.replaceAt)(newValues, i, _this.normalizeValue(values[i] + deltaValue, i));\n                    }\n                    _this.setState({\n                        draggedTrackPos: [clientX, clientY],\n                    });\n                    onChange(newValues);\n                }\n            }\n            else {\n                var newValue = 0;\n                switch (direction) {\n                    case types_1.Direction.Right:\n                        newValue =\n                            ((clientX - trackRect.left) / trackLength) * (max - min) + min;\n                        break;\n                    case types_1.Direction.Left:\n                        newValue =\n                            ((trackLength - (clientX - trackRect.left)) / trackLength) *\n                                (max - min) +\n                                min;\n                        break;\n                    case types_1.Direction.Down:\n                        newValue =\n                            ((clientY - trackRect.top) / trackLength) * (max - min) + min;\n                        break;\n                    case types_1.Direction.Up:\n                        newValue =\n                            ((trackLength - (clientY - trackRect.top)) / trackLength) *\n                                (max - min) +\n                                min;\n                        break;\n                    default:\n                        (0, utils_1.assertUnreachable)(direction);\n                }\n                // invert for RTL\n                if (rtl) {\n                    newValue = max + min - newValue;\n                }\n                if (Math.abs(values[draggedThumbIndex] - newValue) >= step / 2) {\n                    onChange((0, utils_1.replaceAt)(values, draggedThumbIndex, _this.normalizeValue(newValue, draggedThumbIndex)));\n                }\n            }\n        };\n        _this.normalizeValue = function (value, index) {\n            var _a = _this.props, min = _a.min, max = _a.max, step = _a.step, allowOverlap = _a.allowOverlap, values = _a.values;\n            return (0, utils_1.normalizeValue)(value, index, min, max, step, allowOverlap, values);\n        };\n        _this.onEnd = function (e) {\n            e.preventDefault();\n            document.removeEventListener(\"mousemove\", _this.schdOnMouseMove);\n            document.removeEventListener(\"touchmove\", _this.schdOnTouchMove);\n            document.removeEventListener(\"mouseup\", _this.schdOnEnd);\n            document.removeEventListener(\"touchend\", _this.schdOnEnd);\n            document.removeEventListener(\"touchcancel\", _this.schdOnEnd);\n            if (_this.state.draggedThumbIndex === -1 &&\n                _this.state.draggedTrackPos[0] === -1 &&\n                _this.state.draggedTrackPos[1] === -1)\n                return null;\n            _this.setState({ draggedThumbIndex: -1, draggedTrackPos: [-1, -1] }, function () {\n                _this.fireOnFinalChange();\n            });\n        };\n        _this.fireOnFinalChange = function () {\n            _this.setState({ isChanged: false });\n            var _a = _this.props, onFinalChange = _a.onFinalChange, values = _a.values;\n            if (onFinalChange) {\n                onFinalChange(values);\n            }\n        };\n        _this.updateMarkRefs = function (props) {\n            if (!props.renderMark) {\n                // don't create mark refs unless we are rendering marks\n                _this.numOfMarks = undefined;\n                _this.markRefs = undefined;\n                return;\n            }\n            _this.numOfMarks = (props.max - props.min) / _this.props.step;\n            _this.markRefs = [];\n            for (var i = 0; i < _this.numOfMarks + 1; i++) {\n                _this.markRefs[i] = React.createRef();\n            }\n        };\n        _this.calculateMarkOffsets = function () {\n            if (!_this.props.renderMark ||\n                !_this.trackRef ||\n                !_this.numOfMarks ||\n                !_this.markRefs ||\n                _this.trackRef.current === null)\n                return;\n            var elStyles = window.getComputedStyle(_this.trackRef.current);\n            var trackWidth = parseInt(elStyles.width, 10);\n            var trackHeight = parseInt(elStyles.height, 10);\n            var paddingLeft = parseInt(elStyles.paddingLeft, 10);\n            var paddingTop = parseInt(elStyles.paddingTop, 10);\n            var res = [];\n            for (var i = 0; i < _this.numOfMarks + 1; i++) {\n                var markHeight = 9999;\n                var markWidth = 9999;\n                if (_this.markRefs[i].current) {\n                    var markRect = _this.markRefs[i].current.getBoundingClientRect();\n                    markHeight = markRect.height;\n                    markWidth = markRect.width;\n                }\n                if (_this.props.direction === types_1.Direction.Left ||\n                    _this.props.direction === types_1.Direction.Right) {\n                    res.push([\n                        Math.round((trackWidth / _this.numOfMarks) * i + paddingLeft - markWidth / 2),\n                        -Math.round((markHeight - trackHeight) / 2),\n                    ]);\n                }\n                else {\n                    res.push([\n                        Math.round((trackHeight / _this.numOfMarks) * i + paddingTop - markHeight / 2),\n                        -Math.round((markWidth - trackWidth) / 2),\n                    ]);\n                }\n            }\n            _this.setState({ markOffsets: res });\n        };\n        if (props.step === 0) {\n            throw new Error('\"step\" property should be a positive number');\n        }\n        _this.schdOnMouseMove = (0, utils_1.schd)(_this.onMouseMove);\n        _this.schdOnTouchMove = (0, utils_1.schd)(_this.onTouchMove);\n        _this.schdOnEnd = (0, utils_1.schd)(_this.onEnd);\n        _this.thumbRefs = props.values.map(function () { return React.createRef(); });\n        _this.updateMarkRefs(props);\n        return _this;\n    }\n    Range.prototype.componentDidMount = function () {\n        var _this = this;\n        var _a = this.props, values = _a.values, min = _a.min, step = _a.step;\n        this.resizeObserver = window.ResizeObserver\n            ? new window.ResizeObserver(this.onResize)\n            : {\n                observe: function () { return window.addEventListener(\"resize\", _this.onResize); },\n                unobserve: function () { return window.removeEventListener(\"resize\", _this.onResize); },\n            };\n        document.addEventListener(\"touchstart\", this.onMouseOrTouchStart, {\n            passive: false,\n        });\n        document.addEventListener(\"mousedown\", this.onMouseOrTouchStart, {\n            passive: false,\n        });\n        !this.props.allowOverlap && (0, utils_1.checkInitialOverlap)(this.props.values);\n        this.props.values.forEach(function (value) {\n            return (0, utils_1.checkBoundaries)(value, _this.props.min, _this.props.max);\n        });\n        this.resizeObserver.observe(this.trackRef.current);\n        (0, utils_1.translateThumbs)(this.getThumbs(), this.getOffsets(), this.props.rtl);\n        this.calculateMarkOffsets();\n        values.forEach(function (value) {\n            if (!(0, utils_1.isStepDivisible)(min, value, step)) {\n                console.warn(\"The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.\");\n            }\n        });\n    };\n    Range.prototype.componentDidUpdate = function (prevProps, prevState) {\n        var _a = this.props, max = _a.max, min = _a.min, step = _a.step, values = _a.values, rtl = _a.rtl;\n        if (prevProps.max !== max ||\n            prevProps.min !== min ||\n            prevProps.step !== step) {\n            this.updateMarkRefs(this.props);\n        }\n        (0, utils_1.translateThumbs)(this.getThumbs(), this.getOffsets(), rtl);\n        // ensure offsets are calculated when the refs for the marks have been created\n        // and those refs have been mounted to the dom\n        // on the state update in calculateOffsets with new markOffsets are calculated\n        if (prevProps.max !== max ||\n            prevProps.min !== min ||\n            prevProps.step !== step ||\n            prevState.markOffsets.length !== this.state.markOffsets.length) {\n            this.calculateMarkOffsets();\n            values.forEach(function (value) {\n                if (!(0, utils_1.isStepDivisible)(min, value, step)) {\n                    console.warn(\"The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.\");\n                }\n            });\n        }\n    };\n    Range.prototype.componentWillUnmount = function () {\n        var options = {\n            passive: false,\n        };\n        document.removeEventListener(\"mousedown\", this.onMouseOrTouchStart, options);\n        // These need to be removed!!\n        document.removeEventListener(\"mousemove\", this.schdOnMouseMove);\n        document.removeEventListener(\"touchmove\", this.schdOnTouchMove);\n        document.removeEventListener(\"touchstart\", this.onMouseOrTouchStart);\n        document.removeEventListener(\"mouseup\", this.schdOnEnd);\n        document.removeEventListener(\"touchend\", this.schdOnEnd);\n        this.resizeObserver.unobserve(this.trackRef.current);\n    };\n    Range.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, label = _a.label, labelledBy = _a.labelledBy, renderTrack = _a.renderTrack, renderThumb = _a.renderThumb, _b = _a.renderMark, renderMark = _b === void 0 ? function () { return null; } : _b, values = _a.values, min = _a.min, max = _a.max, allowOverlap = _a.allowOverlap, disabled = _a.disabled;\n        var _c = this.state, draggedThumbIndex = _c.draggedThumbIndex, thumbZIndexes = _c.thumbZIndexes, markOffsets = _c.markOffsets;\n        return renderTrack({\n            props: {\n                style: {\n                    // creates stacking context that prevents z-index applied to thumbs\n                    // interfere with other elements\n                    transform: \"scale(1)\",\n                    cursor: draggedThumbIndex > -1\n                        ? \"grabbing\"\n                        : this.props.draggableTrack\n                            ? (0, utils_1.isVertical)(this.props.direction)\n                                ? \"ns-resize\"\n                                : \"ew-resize\"\n                            : values.length === 1 && !disabled\n                                ? \"pointer\"\n                                : \"inherit\",\n                },\n                onMouseDown: disabled ? utils_1.voidFn : this.onMouseDownTrack,\n                onTouchStart: disabled ? utils_1.voidFn : this.onTouchStartTrack,\n                ref: this.trackRef,\n            },\n            isDragged: this.state.draggedThumbIndex > -1,\n            disabled: disabled,\n            children: __spreadArray(__spreadArray([], markOffsets.map(function (offset, index, arr) {\n                return renderMark({\n                    props: {\n                        style: _this.props.direction === types_1.Direction.Left ||\n                            _this.props.direction === types_1.Direction.Right\n                            ? {\n                                position: \"absolute\",\n                                left: \"\".concat(offset[0], \"px\"),\n                                marginTop: \"\".concat(offset[1], \"px\"),\n                            }\n                            : {\n                                position: \"absolute\",\n                                top: \"\".concat(offset[0], \"px\"),\n                                marginLeft: \"\".concat(offset[1], \"px\"),\n                            },\n                        key: \"mark\".concat(index),\n                        ref: _this.markRefs[index],\n                    },\n                    index: index,\n                });\n            }), true), values.map(function (value, index) {\n                var isDragged = _this.state.draggedThumbIndex === index;\n                return renderThumb({\n                    index: index,\n                    value: value,\n                    isDragged: isDragged,\n                    props: {\n                        style: {\n                            position: \"absolute\",\n                            zIndex: thumbZIndexes[index],\n                            cursor: disabled ? \"inherit\" : isDragged ? \"grabbing\" : \"grab\",\n                            userSelect: \"none\",\n                            touchAction: \"none\",\n                            WebkitUserSelect: \"none\",\n                            MozUserSelect: \"none\",\n                            msUserSelect: \"none\",\n                        },\n                        key: index,\n                        tabIndex: disabled ? undefined : 0,\n                        \"aria-valuemax\": allowOverlap ? max : values[index + 1] || max,\n                        \"aria-valuemin\": allowOverlap ? min : values[index - 1] || min,\n                        \"aria-valuenow\": value,\n                        draggable: false,\n                        ref: _this.thumbRefs[index],\n                        \"aria-label\": label,\n                        \"aria-labelledby\": labelledBy,\n                        role: \"slider\",\n                        onKeyDown: disabled ? utils_1.voidFn : _this.onKeyDown,\n                        onKeyUp: disabled ? utils_1.voidFn : _this.onKeyUp,\n                    },\n                });\n            }), true),\n        });\n    };\n    Range.defaultProps = {\n        label: \"Accessibility label\",\n        labelledBy: null,\n        step: 1,\n        direction: types_1.Direction.Right,\n        rtl: false,\n        disabled: false,\n        allowOverlap: false,\n        draggableTrack: false,\n        min: 0,\n        max: 100,\n    };\n    return Range;\n}(React.Component));\nexports[\"default\"] = Range;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL1JhbmdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLG1CQUFPLENBQUMsd0dBQU87QUFDeEMsY0FBYyxtQkFBTyxDQUFDLDhEQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyw4REFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLFdBQVc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoYm9hcmQtYXBwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJhbmdlL2xpYi9SYW5nZS5qcz8wZTkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBJTkNSRUFTRV9LRVlTID0gW1wiQXJyb3dSaWdodFwiLCBcIkFycm93VXBcIiwgXCJrXCIsIFwiUGFnZVVwXCJdO1xudmFyIERFQ1JFQVNFX0tFWVMgPSBbXCJBcnJvd0xlZnRcIiwgXCJBcnJvd0Rvd25cIiwgXCJqXCIsIFwiUGFnZURvd25cIl07XG52YXIgUmFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJhbmdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhbmdlKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50cmFja1JlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy50aHVtYlJlZnMgPSBbXTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3M6IFstMSwgLTFdLFxuICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IC0xLFxuICAgICAgICAgICAgdGh1bWJaSW5kZXhlczogbmV3IEFycmF5KF90aGlzLnByb3BzLnZhbHVlcy5sZW5ndGgpLmZpbGwoMCkubWFwKGZ1bmN0aW9uICh0LCBpKSB7IHJldHVybiBpOyB9KSxcbiAgICAgICAgICAgIGlzQ2hhbmdlZDogZmFsc2UsXG4gICAgICAgICAgICBtYXJrT2Zmc2V0czogW10sXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldE9mZnNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4O1xuICAgICAgICAgICAgdmFyIHRyYWNrRWxlbWVudCA9IF90aGlzLnRyYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIXRyYWNrRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIHRyYWNrIGVsZW1lbnQgZm91bmQuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmFja1JlY3QgPSB0cmFja0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tQYWRkaW5nID0gKDAsIHV0aWxzXzEuZ2V0UGFkZGluZ0FuZEJvcmRlcikodHJhY2tFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRUaHVtYnMoKS5tYXAoZnVuY3Rpb24gKHRodW1iLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciB0aHVtYk9mZnNldHMgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgICAgICAgICB2YXIgdGh1bWJSZWN0ID0gdGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHRodW1iTWFyZ2lucyA9ICgwLCB1dGlsc18xLmdldE1hcmdpbikodGh1bWIpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueCA9ICh0aHVtYk1hcmdpbnMubGVmdCArIHRyYWNrUGFkZGluZy5sZWZ0KSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodGh1bWJSZWN0LmhlaWdodCAtIHRyYWNrUmVjdC5oZWlnaHQpIC8gMiArIHRyYWNrUGFkZGluZy50b3ApICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueCArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVjdC53aWR0aCAqICgwLCB1dGlsc18xLnJlbGF0aXZlVmFsdWUpKHZhbHVlc1tpbmRleF0sIG1pbiwgbWF4KSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iUmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGh1bWJPZmZzZXRzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueCA9ICh0aHVtYk1hcmdpbnMucmlnaHQgKyB0cmFja1BhZGRpbmcucmlnaHQpICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh0aHVtYlJlY3QuaGVpZ2h0IC0gdHJhY2tSZWN0LmhlaWdodCkgLyAyICsgdHJhY2tQYWRkaW5nLnRvcCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LndpZHRoIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LndpZHRoICogKDAsIHV0aWxzXzEucmVsYXRpdmVWYWx1ZSkodmFsdWVzW2luZGV4XSwgbWluLCBtYXgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHVtYk9mZnNldHM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uVXA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh0aHVtYlJlY3Qud2lkdGggLSB0cmFja1JlY3Qud2lkdGgpIC8gMiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iTWFyZ2lucy5sZWZ0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tQYWRkaW5nLmxlZnQpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSA9IC10cmFja1BhZGRpbmcubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy55ICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LmhlaWdodCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVjdC5oZWlnaHQgKiAoMCwgdXRpbHNfMS5yZWxhdGl2ZVZhbHVlKSh2YWx1ZXNbaW5kZXhdLCBtaW4sIG1heCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYlJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHVtYk9mZnNldHM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uRG93bjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHRodW1iUmVjdC53aWR0aCAtIHRyYWNrUmVjdC53aWR0aCkgLyAyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJNYXJnaW5zLmxlZnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1BhZGRpbmcubGVmdCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy55ID0gLXRyYWNrUGFkZGluZy5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnkgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1JlY3QuaGVpZ2h0ICogKDAsIHV0aWxzXzEucmVsYXRpdmVWYWx1ZSkodmFsdWVzW2luZGV4XSwgbWluLCBtYXgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGh1bWJPZmZzZXRzO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmFzc2VydFVucmVhY2hhYmxlKShkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRUaHVtYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMudHJhY2tSZWYgJiYgX3RoaXMudHJhY2tSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKF90aGlzLnRyYWNrUmVmLmN1cnJlbnQuY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZShcImFyaWEtdmFsdWVub3dcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyB0aHVtYnMgZm91bmQgaW4gdGhlIHRyYWNrIGNvbnRhaW5lci4gRGlkIHlvdSBmb3JnZXQgdG8gcGFzcyAmIHNwcmVhZCB0aGUgYHByb3BzYCBwYXJhbSBpbiByZW5kZXJUcmFjaz9cIik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldFRhcmdldEluZGV4ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRUaHVtYnMoKS5maW5kSW5kZXgoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZCA9PT0gZS50YXJnZXQgfHwgY2hpbGQuY29udGFpbnMoZS50YXJnZXQpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYWRkVG91Y2hFdmVudHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBfdGhpcy5zY2hkT25Ub3VjaE1vdmUsIHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90aGlzLnNjaGRPbkVuZCwge1xuICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgX3RoaXMuc2NoZE9uRW5kLCB7XG4gICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYWRkTW91c2VFdmVudHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfdGhpcy5zY2hkT25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgX3RoaXMuc2NoZE9uRW5kKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Nb3VzZURvd25UcmFjayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoZS5idXR0b24gIT09IDAgfHwgKDAsIHV0aWxzXzEuaXNJT1MpKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZS5wZXJzaXN0KCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBfdGhpcy5hZGRNb3VzZUV2ZW50cyhlLm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy52YWx1ZXMubGVuZ3RoID4gMSAmJiBfdGhpcy5wcm9wcy5kcmFnZ2FibGVUcmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50aHVtYlJlZnMuc29tZShmdW5jdGlvbiAodGh1bWJSZWYpIHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGh1bWJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGUudGFyZ2V0KTsgfSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZHJhZ2dpbmcgdGhlIHdob2xlIHRyYWNrXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3M6IFtlLmNsaWVudFgsIGUuY2xpZW50WV0sXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25Nb3ZlKGUuY2xpZW50WCwgZS5jbGllbnRZKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IG9mIHRoZSB0aHVtYiB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIHBsYWNlIHdoZXJlIHRoZSB0cmFjayBpcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdnZWRUaHVtYkluZGV4ID0gKDAsIHV0aWxzXzEuZ2V0Q2xvc2VzdFRodW1iSW5kZXgpKF90aGlzLnRodW1iUmVmcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuY3VycmVudDsgfSksIGUuY2xpZW50WCwgZS5jbGllbnRZLCBfdGhpcy5wcm9wcy5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIHRodW1iIHdoaWNoIGlzIGNsb3Nlc3QgdG8gdGhlIHBsYWNlIHdoZXJlIHRoZSB0cmFjayBpcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgKF9hID0gX3RoaXMudGh1bWJSZWZzW2RyYWdnZWRUaHVtYkluZGV4XS5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUaHVtYkluZGV4OiBkcmFnZ2VkVGh1bWJJbmRleCxcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbk1vdmUoZS5jbGllbnRYLCBlLmNsaWVudFkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAoMCwgdXRpbHNfMS50cmFuc2xhdGVUaHVtYnMpKF90aGlzLmdldFRodW1icygpLCBfdGhpcy5nZXRPZmZzZXRzKCksIF90aGlzLnByb3BzLnJ0bCk7XG4gICAgICAgICAgICBfdGhpcy5jYWxjdWxhdGVNYXJrT2Zmc2V0cygpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblRvdWNoU3RhcnRUcmFjayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBlLnBlcnNpc3QoKTtcbiAgICAgICAgICAgIF90aGlzLmFkZFRvdWNoRXZlbnRzKGUubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnZhbHVlcy5sZW5ndGggPiAxICYmIF90aGlzLnByb3BzLmRyYWdnYWJsZVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRodW1iUmVmcy5zb21lKGZ1bmN0aW9uICh0aHVtYlJlZikgeyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aHVtYlJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnMoZS50YXJnZXQpOyB9KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBkcmFnZ2luZyB0aGUgd2hvbGUgdHJhY2tcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUcmFja1BvczogW2UudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WV0sXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25Nb3ZlKGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgdGh1bWIgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBwbGFjZSB3aGVyZSB0aGUgdHJhY2sgaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIHZhciBkcmFnZ2VkVGh1bWJJbmRleCA9ICgwLCB1dGlsc18xLmdldENsb3Nlc3RUaHVtYkluZGV4KShfdGhpcy50aHVtYlJlZnMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmN1cnJlbnQ7IH0pLCBlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFksIF90aGlzLnByb3BzLmRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgdGh1bWIgd2hpY2ggaXMgY2xvc2VzdCB0byB0aGUgcGxhY2Ugd2hlcmUgdGhlIHRyYWNrIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy50aHVtYlJlZnNbZHJhZ2dlZFRodW1iSW5kZXhdLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IGRyYWdnZWRUaHVtYkluZGV4LFxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uTW92ZShlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Nb3VzZU9yVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlzVG91Y2ggPSAoMCwgdXRpbHNfMS5pc1RvdWNoRXZlbnQpKGUpO1xuICAgICAgICAgICAgaWYgKCFpc1RvdWNoICYmIGUuYnV0dG9uICE9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLmdldFRhcmdldEluZGV4KGUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZFRvdWNoRXZlbnRzKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkTW91c2VFdmVudHMoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIHRodW1iWkluZGV4ZXM6IF90aGlzLnN0YXRlLnRodW1iWkluZGV4ZXMubWFwKGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIF90aGlzLnN0YXRlLnRodW1iWkluZGV4ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0IDw9IF90aGlzLnN0YXRlLnRodW1iWkluZGV4ZXNbaW5kZXhdID8gdCA6IHQgLSAxO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzLm9uTW92ZShlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzLm9uTW92ZShlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIHZhbHVlcyA9IF9hLnZhbHVlcywgb25DaGFuZ2UgPSBfYS5vbkNoYW5nZSwgc3RlcCA9IF9hLnN0ZXAsIHJ0bCA9IF9hLnJ0bCwgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uO1xuICAgICAgICAgICAgdmFyIGlzQ2hhbmdlZCA9IF90aGlzLnN0YXRlLmlzQ2hhbmdlZDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLmdldFRhcmdldEluZGV4KGUubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgdmFyIGludmVydGVyID0gcnRsIHx8IGRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uTGVmdCB8fCBkaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLkRvd25cbiAgICAgICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoSU5DUkVBU0VfS0VZUy5pbmNsdWRlcyhlLmtleSkpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGlzQ2hhbmdlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZSgoMCwgdXRpbHNfMS5yZXBsYWNlQXQpKHZhbHVlcywgaW5kZXgsIF90aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbHVlc1tpbmRleF0gKyBpbnZlcnRlciAqIChlLmtleSA9PT0gXCJQYWdlVXBcIiA/IHN0ZXAgKiAxMCA6IHN0ZXApLCBpbmRleCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKERFQ1JFQVNFX0tFWVMuaW5jbHVkZXMoZS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpc0NoYW5nZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2UoKDAsIHV0aWxzXzEucmVwbGFjZUF0KSh2YWx1ZXMsIGluZGV4LCBfdGhpcy5ub3JtYWxpemVWYWx1ZSh2YWx1ZXNbaW5kZXhdIC1cbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ZXIgKiAoZS5rZXkgPT09IFwiUGFnZURvd25cIiA/IHN0ZXAgKiAxMCA6IHN0ZXApLCBpbmRleCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBkcmFnZ2VkVGh1bWJJbmRleDogLTEgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBrZXkgcHJlc3NlZCB3aGVuIHRodW1iIHdhcyBtb3ZpbmcsIGZpcmUgb25GaW5hbENoYW5nZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maXJlT25GaW5hbENoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpcmVPbkZpbmFsQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbktleVVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBpc0NoYW5nZWQgPSBfdGhpcy5zdGF0ZS5pc0NoYW5nZWQ7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IC0xLFxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyZU9uRmluYWxDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Nb3ZlID0gZnVuY3Rpb24gKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlLCBkcmFnZ2VkVGh1bWJJbmRleCA9IF9hLmRyYWdnZWRUaHVtYkluZGV4LCBkcmFnZ2VkVHJhY2tQb3MgPSBfYS5kcmFnZ2VkVHJhY2tQb3M7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZGlyZWN0aW9uID0gX2IuZGlyZWN0aW9uLCBtaW4gPSBfYi5taW4sIG1heCA9IF9iLm1heCwgb25DaGFuZ2UgPSBfYi5vbkNoYW5nZSwgdmFsdWVzID0gX2IudmFsdWVzLCBzdGVwID0gX2Iuc3RlcCwgcnRsID0gX2IucnRsO1xuICAgICAgICAgICAgaWYgKGRyYWdnZWRUaHVtYkluZGV4ID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIGRyYWdnZWRUcmFja1Bvc1swXSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3NbMV0gPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHRyYWNrRWxlbWVudCA9IF90aGlzLnRyYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAvLyBJZiBjb21wb25lbnQgd2FzIGNsb3NlZCBkb3duIHByZW1hdHVyZWx5LCBBIGxhc3Qgb25Nb3ZlIGNvdWxkIGJlIHRyaWdnZXJlZCBiYXNlZCBvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKVxuICAgICAgICAgICAgaWYgKCF0cmFja0VsZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgdHJhY2tSZWN0ID0gdHJhY2tFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHRyYWNrTGVuZ3RoID0gKDAsIHV0aWxzXzEuaXNWZXJ0aWNhbCkoZGlyZWN0aW9uKVxuICAgICAgICAgICAgICAgID8gdHJhY2tSZWN0LmhlaWdodFxuICAgICAgICAgICAgICAgIDogdHJhY2tSZWN0LndpZHRoO1xuICAgICAgICAgICAgaWYgKGRyYWdnZWRUcmFja1Bvc1swXSAhPT0gLTEgJiYgZHJhZ2dlZFRyYWNrUG9zWzFdICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBob3cgbXVjaCBpdCBtb3ZlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGVcbiAgICAgICAgICAgICAgICB2YXIgZFggPSBjbGllbnRYIC0gZHJhZ2dlZFRyYWNrUG9zWzBdO1xuICAgICAgICAgICAgICAgIHZhciBkWSA9IGNsaWVudFkgLSBkcmFnZ2VkVHJhY2tQb3NbMV07XG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkZWx0YSBvZiB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5SaWdodDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFWYWx1ZSA9IChkWCAvIHRyYWNrTGVuZ3RoKSAqIChtYXggLSBtaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uRG93bjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5VcDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSAoZFkgLyB0cmFja0xlbmd0aCkgKiAobWF4IC0gbWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0VW5yZWFjaGFibGUpKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludmVydCBmb3IgUlRMXG4gICAgICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVZhbHVlICo9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGFWYWx1ZSkgPj0gc3RlcCAvIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRqdXN0IGRlbHRhIHNvIGl0IGZpdHMgaW50byB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy50aHVtYlJlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWVzW2ldID09PSBtYXggJiYgTWF0aC5zaWduKGRlbHRhVmFsdWUpID09PSAxKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh2YWx1ZXNbaV0gPT09IG1pbiAmJiBNYXRoLnNpZ24oZGVsdGFWYWx1ZSkgPT09IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGh1bWJWYWx1ZSA9IHZhbHVlc1tpXSArIGRlbHRhVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGh1bWJWYWx1ZSA+IG1heClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVZhbHVlID0gbWF4IC0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGh1bWJWYWx1ZSA8IG1pbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVZhbHVlID0gbWluIC0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgZGVsdGEgdG8gZWFjaCB0aHVtYlxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWVzID0gdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLnRodW1iUmVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzID0gKDAsIHV0aWxzXzEucmVwbGFjZUF0KShuZXdWYWx1ZXMsIGksIF90aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbHVlc1tpXSArIGRlbHRhVmFsdWUsIGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3M6IFtjbGllbnRYLCBjbGllbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKG5ld1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoY2xpZW50WCAtIHRyYWNrUmVjdC5sZWZ0KSAvIHRyYWNrTGVuZ3RoKSAqIChtYXggLSBtaW4pICsgbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uTGVmdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHRyYWNrTGVuZ3RoIC0gKGNsaWVudFggLSB0cmFja1JlY3QubGVmdCkpIC8gdHJhY2tMZW5ndGgpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1heCAtIG1pbikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5Eb3duOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoY2xpZW50WSAtIHRyYWNrUmVjdC50b3ApIC8gdHJhY2tMZW5ndGgpICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5VcDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHRyYWNrTGVuZ3RoIC0gKGNsaWVudFkgLSB0cmFja1JlY3QudG9wKSkgLyB0cmFja0xlbmd0aCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF4IC0gbWluKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0VW5yZWFjaGFibGUpKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludmVydCBmb3IgUlRMXG4gICAgICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG1heCArIG1pbiAtIG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModmFsdWVzW2RyYWdnZWRUaHVtYkluZGV4XSAtIG5ld1ZhbHVlKSA+PSBzdGVwIC8gMikge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSgoMCwgdXRpbHNfMS5yZXBsYWNlQXQpKHZhbHVlcywgZHJhZ2dlZFRodW1iSW5kZXgsIF90aGlzLm5vcm1hbGl6ZVZhbHVlKG5ld1ZhbHVlLCBkcmFnZ2VkVGh1bWJJbmRleCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm5vcm1hbGl6ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4LCBzdGVwID0gX2Euc3RlcCwgYWxsb3dPdmVybGFwID0gX2EuYWxsb3dPdmVybGFwLCB2YWx1ZXMgPSBfYS52YWx1ZXM7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEubm9ybWFsaXplVmFsdWUpKHZhbHVlLCBpbmRleCwgbWluLCBtYXgsIHN0ZXAsIGFsbG93T3ZlcmxhcCwgdmFsdWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfdGhpcy5zY2hkT25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBfdGhpcy5zY2hkT25Ub3VjaE1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgX3RoaXMuc2NoZE9uRW5kKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBfdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIF90aGlzLnNjaGRPbkVuZCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuZHJhZ2dlZFRodW1iSW5kZXggPT09IC0xICYmXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUuZHJhZ2dlZFRyYWNrUG9zWzBdID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlLmRyYWdnZWRUcmFja1Bvc1sxXSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGRyYWdnZWRUaHVtYkluZGV4OiAtMSwgZHJhZ2dlZFRyYWNrUG9zOiBbLTEsIC0xXSB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyZU9uRmluYWxDaGFuZ2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5maXJlT25GaW5hbENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaXNDaGFuZ2VkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBvbkZpbmFsQ2hhbmdlID0gX2Eub25GaW5hbENoYW5nZSwgdmFsdWVzID0gX2EudmFsdWVzO1xuICAgICAgICAgICAgaWYgKG9uRmluYWxDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBvbkZpbmFsQ2hhbmdlKHZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnVwZGF0ZU1hcmtSZWZzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BzLnJlbmRlck1hcmspIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBjcmVhdGUgbWFyayByZWZzIHVubGVzcyB3ZSBhcmUgcmVuZGVyaW5nIG1hcmtzXG4gICAgICAgICAgICAgICAgX3RoaXMubnVtT2ZNYXJrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBfdGhpcy5tYXJrUmVmcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5udW1PZk1hcmtzID0gKHByb3BzLm1heCAtIHByb3BzLm1pbikgLyBfdGhpcy5wcm9wcy5zdGVwO1xuICAgICAgICAgICAgX3RoaXMubWFya1JlZnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMubnVtT2ZNYXJrcyArIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIF90aGlzLm1hcmtSZWZzW2ldID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNhbGN1bGF0ZU1hcmtPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5yZW5kZXJNYXJrIHx8XG4gICAgICAgICAgICAgICAgIV90aGlzLnRyYWNrUmVmIHx8XG4gICAgICAgICAgICAgICAgIV90aGlzLm51bU9mTWFya3MgfHxcbiAgICAgICAgICAgICAgICAhX3RoaXMubWFya1JlZnMgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFja1JlZi5jdXJyZW50ID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBlbFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKF90aGlzLnRyYWNrUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgdmFyIHRyYWNrV2lkdGggPSBwYXJzZUludChlbFN0eWxlcy53aWR0aCwgMTApO1xuICAgICAgICAgICAgdmFyIHRyYWNrSGVpZ2h0ID0gcGFyc2VJbnQoZWxTdHlsZXMuaGVpZ2h0LCAxMCk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUludChlbFN0eWxlcy5wYWRkaW5nTGVmdCwgMTApO1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdUb3AgPSBwYXJzZUludChlbFN0eWxlcy5wYWRkaW5nVG9wLCAxMCk7XG4gICAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLm51bU9mTWFya3MgKyAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFya0hlaWdodCA9IDk5OTk7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtXaWR0aCA9IDk5OTk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm1hcmtSZWZzW2ldLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtSZWN0ID0gX3RoaXMubWFya1JlZnNbaV0uY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgbWFya0hlaWdodCA9IG1hcmtSZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbWFya1dpZHRoID0gbWFya1JlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQgfHxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5SaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCh0cmFja1dpZHRoIC8gX3RoaXMubnVtT2ZNYXJrcykgKiBpICsgcGFkZGluZ0xlZnQgLSBtYXJrV2lkdGggLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC1NYXRoLnJvdW5kKChtYXJrSGVpZ2h0IC0gdHJhY2tIZWlnaHQpIC8gMiksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgodHJhY2tIZWlnaHQgLyBfdGhpcy5udW1PZk1hcmtzKSAqIGkgKyBwYWRkaW5nVG9wIC0gbWFya0hlaWdodCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLU1hdGgucm91bmQoKG1hcmtXaWR0aCAtIHRyYWNrV2lkdGgpIC8gMiksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgbWFya09mZnNldHM6IHJlcyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb3BzLnN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJzdGVwXCIgcHJvcGVydHkgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc2NoZE9uTW91c2VNb3ZlID0gKDAsIHV0aWxzXzEuc2NoZCkoX3RoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICBfdGhpcy5zY2hkT25Ub3VjaE1vdmUgPSAoMCwgdXRpbHNfMS5zY2hkKShfdGhpcy5vblRvdWNoTW92ZSk7XG4gICAgICAgIF90aGlzLnNjaGRPbkVuZCA9ICgwLCB1dGlsc18xLnNjaGQpKF90aGlzLm9uRW5kKTtcbiAgICAgICAgX3RoaXMudGh1bWJSZWZzID0gcHJvcHMudmFsdWVzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBSZWFjdC5jcmVhdGVSZWYoKTsgfSk7XG4gICAgICAgIF90aGlzLnVwZGF0ZU1hcmtSZWZzKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSYW5nZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHZhbHVlcyA9IF9hLnZhbHVlcywgbWluID0gX2EubWluLCBzdGVwID0gX2Euc3RlcDtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IHdpbmRvdy5SZXNpemVPYnNlcnZlclxuICAgICAgICAgICAgPyBuZXcgd2luZG93LlJlc2l6ZU9ic2VydmVyKHRoaXMub25SZXNpemUpXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBfdGhpcy5vblJlc2l6ZSk7IH0sXG4gICAgICAgICAgICAgICAgdW5vYnNlcnZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBfdGhpcy5vblJlc2l6ZSk7IH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLm9uTW91c2VPclRvdWNoU3RhcnQsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VPclRvdWNoU3RhcnQsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgIXRoaXMucHJvcHMuYWxsb3dPdmVybGFwICYmICgwLCB1dGlsc18xLmNoZWNrSW5pdGlhbE92ZXJsYXApKHRoaXMucHJvcHMudmFsdWVzKTtcbiAgICAgICAgdGhpcy5wcm9wcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jaGVja0JvdW5kYXJpZXMpKHZhbHVlLCBfdGhpcy5wcm9wcy5taW4sIF90aGlzLnByb3BzLm1heCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy50cmFja1JlZi5jdXJyZW50KTtcbiAgICAgICAgKDAsIHV0aWxzXzEudHJhbnNsYXRlVGh1bWJzKSh0aGlzLmdldFRodW1icygpLCB0aGlzLmdldE9mZnNldHMoKSwgdGhpcy5wcm9wcy5ydGwpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZU1hcmtPZmZzZXRzKCk7XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc1N0ZXBEaXZpc2libGUpKG1pbiwgdmFsdWUsIHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIGB2YWx1ZXNgIHByb3BlcnR5IGlzIGluIGNvbmZsaWN0IHdpdGggdGhlIGN1cnJlbnQgYHN0ZXBgLCBgbWluYCwgYW5kIGBtYXhgIHByb3BlcnRpZXMuIFBsZWFzZSBwcm92aWRlIHZhbHVlcyB0aGF0IGFyZSBhY2Nlc3NpYmxlIHVzaW5nIHRoZSBtaW4sIG1heCwgYW5kIHN0ZXAgdmFsdWVzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIG1heCA9IF9hLm1heCwgbWluID0gX2EubWluLCBzdGVwID0gX2Euc3RlcCwgdmFsdWVzID0gX2EudmFsdWVzLCBydGwgPSBfYS5ydGw7XG4gICAgICAgIGlmIChwcmV2UHJvcHMubWF4ICE9PSBtYXggfHxcbiAgICAgICAgICAgIHByZXZQcm9wcy5taW4gIT09IG1pbiB8fFxuICAgICAgICAgICAgcHJldlByb3BzLnN0ZXAgIT09IHN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWFya1JlZnModGhpcy5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHV0aWxzXzEudHJhbnNsYXRlVGh1bWJzKSh0aGlzLmdldFRodW1icygpLCB0aGlzLmdldE9mZnNldHMoKSwgcnRsKTtcbiAgICAgICAgLy8gZW5zdXJlIG9mZnNldHMgYXJlIGNhbGN1bGF0ZWQgd2hlbiB0aGUgcmVmcyBmb3IgdGhlIG1hcmtzIGhhdmUgYmVlbiBjcmVhdGVkXG4gICAgICAgIC8vIGFuZCB0aG9zZSByZWZzIGhhdmUgYmVlbiBtb3VudGVkIHRvIHRoZSBkb21cbiAgICAgICAgLy8gb24gdGhlIHN0YXRlIHVwZGF0ZSBpbiBjYWxjdWxhdGVPZmZzZXRzIHdpdGggbmV3IG1hcmtPZmZzZXRzIGFyZSBjYWxjdWxhdGVkXG4gICAgICAgIGlmIChwcmV2UHJvcHMubWF4ICE9PSBtYXggfHxcbiAgICAgICAgICAgIHByZXZQcm9wcy5taW4gIT09IG1pbiB8fFxuICAgICAgICAgICAgcHJldlByb3BzLnN0ZXAgIT09IHN0ZXAgfHxcbiAgICAgICAgICAgIHByZXZTdGF0ZS5tYXJrT2Zmc2V0cy5sZW5ndGggIT09IHRoaXMuc3RhdGUubWFya09mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZU1hcmtPZmZzZXRzKCk7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmlzU3RlcERpdmlzaWJsZSkobWluLCB2YWx1ZSwgc3RlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIGB2YWx1ZXNgIHByb3BlcnR5IGlzIGluIGNvbmZsaWN0IHdpdGggdGhlIGN1cnJlbnQgYHN0ZXBgLCBgbWluYCwgYW5kIGBtYXhgIHByb3BlcnRpZXMuIFBsZWFzZSBwcm92aWRlIHZhbHVlcyB0aGF0IGFyZSBhY2Nlc3NpYmxlIHVzaW5nIHRoZSBtaW4sIG1heCwgYW5kIHN0ZXAgdmFsdWVzLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMub25Nb3VzZU9yVG91Y2hTdGFydCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIFRoZXNlIG5lZWQgdG8gYmUgcmVtb3ZlZCEhXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5zY2hkT25Nb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuc2NoZE9uVG91Y2hNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5vbk1vdXNlT3JUb3VjaFN0YXJ0KTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSh0aGlzLnRyYWNrUmVmLmN1cnJlbnQpO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgbGFiZWwgPSBfYS5sYWJlbCwgbGFiZWxsZWRCeSA9IF9hLmxhYmVsbGVkQnksIHJlbmRlclRyYWNrID0gX2EucmVuZGVyVHJhY2ssIHJlbmRlclRodW1iID0gX2EucmVuZGVyVGh1bWIsIF9iID0gX2EucmVuZGVyTWFyaywgcmVuZGVyTWFyayA9IF9iID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9IDogX2IsIHZhbHVlcyA9IF9hLnZhbHVlcywgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXgsIGFsbG93T3ZlcmxhcCA9IF9hLmFsbG93T3ZlcmxhcCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZDtcbiAgICAgICAgdmFyIF9jID0gdGhpcy5zdGF0ZSwgZHJhZ2dlZFRodW1iSW5kZXggPSBfYy5kcmFnZ2VkVGh1bWJJbmRleCwgdGh1bWJaSW5kZXhlcyA9IF9jLnRodW1iWkluZGV4ZXMsIG1hcmtPZmZzZXRzID0gX2MubWFya09mZnNldHM7XG4gICAgICAgIHJldHVybiByZW5kZXJUcmFjayh7XG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZXMgc3RhY2tpbmcgY29udGV4dCB0aGF0IHByZXZlbnRzIHotaW5kZXggYXBwbGllZCB0byB0aHVtYnNcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJmZXJlIHdpdGggb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDEpXCIsXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcjogZHJhZ2dlZFRodW1iSW5kZXggPiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImdyYWJiaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5wcm9wcy5kcmFnZ2FibGVUcmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKDAsIHV0aWxzXzEuaXNWZXJ0aWNhbCkodGhpcy5wcm9wcy5kaXJlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJucy1yZXNpemVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiZXctcmVzaXplXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlcy5sZW5ndGggPT09IDEgJiYgIWRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJwb2ludGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImluaGVyaXRcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uTW91c2VEb3duOiBkaXNhYmxlZCA/IHV0aWxzXzEudm9pZEZuIDogdGhpcy5vbk1vdXNlRG93blRyYWNrLFxuICAgICAgICAgICAgICAgIG9uVG91Y2hTdGFydDogZGlzYWJsZWQgPyB1dGlsc18xLnZvaWRGbiA6IHRoaXMub25Ub3VjaFN0YXJ0VHJhY2ssXG4gICAgICAgICAgICAgICAgcmVmOiB0aGlzLnRyYWNrUmVmLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRHJhZ2dlZDogdGhpcy5zdGF0ZS5kcmFnZ2VkVGh1bWJJbmRleCA+IC0xLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICAgICAgY2hpbGRyZW46IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgbWFya09mZnNldHMubWFwKGZ1bmN0aW9uIChvZmZzZXQsIGluZGV4LCBhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyTWFyayh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogX3RoaXMucHJvcHMuZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5SaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIlwiLmNvbmNhdChvZmZzZXRbMF0sIFwicHhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogXCJcIi5jb25jYXQob2Zmc2V0WzFdLCBcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIlwiLmNvbmNhdChvZmZzZXRbMF0sIFwicHhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IFwiXCIuY29uY2F0KG9mZnNldFsxXSwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcIm1hcmtcIi5jb25jYXQoaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBfdGhpcy5tYXJrUmVmc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLCB0cnVlKSwgdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRHJhZ2dlZCA9IF90aGlzLnN0YXRlLmRyYWdnZWRUaHVtYkluZGV4ID09PSBpbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyVGh1bWIoe1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNEcmFnZ2VkOiBpc0RyYWdnZWQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiB0aHVtYlpJbmRleGVzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IGRpc2FibGVkID8gXCJpbmhlcml0XCIgOiBpc0RyYWdnZWQgPyBcImdyYWJiaW5nXCIgOiBcImdyYWJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3VjaEFjdGlvbjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgV2Via2l0VXNlclNlbGVjdDogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTW96VXNlclNlbGVjdDogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNVc2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg6IGRpc2FibGVkID8gdW5kZWZpbmVkIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJpYS12YWx1ZW1heFwiOiBhbGxvd092ZXJsYXAgPyBtYXggOiB2YWx1ZXNbaW5kZXggKyAxXSB8fCBtYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFyaWEtdmFsdWVtaW5cIjogYWxsb3dPdmVybGFwID8gbWluIDogdmFsdWVzW2luZGV4IC0gMV0gfHwgbWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLXZhbHVlbm93XCI6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogX3RoaXMudGh1bWJSZWZzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkQnksXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcInNsaWRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duOiBkaXNhYmxlZCA/IHV0aWxzXzEudm9pZEZuIDogX3RoaXMub25LZXlEb3duLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlVcDogZGlzYWJsZWQgPyB1dGlsc18xLnZvaWRGbiA6IF90aGlzLm9uS2V5VXAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSwgdHJ1ZSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmFuZ2UuZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBsYWJlbDogXCJBY2Nlc3NpYmlsaXR5IGxhYmVsXCIsXG4gICAgICAgIGxhYmVsbGVkQnk6IG51bGwsXG4gICAgICAgIHN0ZXA6IDEsXG4gICAgICAgIGRpcmVjdGlvbjogdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQsXG4gICAgICAgIHJ0bDogZmFsc2UsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgYWxsb3dPdmVybGFwOiBmYWxzZSxcbiAgICAgICAgZHJhZ2dhYmxlVHJhY2s6IGZhbHNlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMTAwLFxuICAgIH07XG4gICAgcmV0dXJuIFJhbmdlO1xufShSZWFjdC5Db21wb25lbnQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJhbmdlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range/lib/Range.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-range/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkValuesAgainstBoundaries = exports.relativeValue = exports.useThumbOverlap = exports.Direction = exports.getTrackBackground = exports.Range = void 0;\nvar Range_1 = __importDefault(__webpack_require__(/*! ./Range */ \"(ssr)/./node_modules/react-range/lib/Range.js\"));\nexports.Range = Range_1.default;\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-range/lib/utils.js\");\nObject.defineProperty(exports, \"getTrackBackground\", ({ enumerable: true, get: function () { return utils_1.getTrackBackground; } }));\nObject.defineProperty(exports, \"useThumbOverlap\", ({ enumerable: true, get: function () { return utils_1.useThumbOverlap; } }));\nObject.defineProperty(exports, \"relativeValue\", ({ enumerable: true, get: function () { return utils_1.relativeValue; } }));\nObject.defineProperty(exports, \"checkValuesAgainstBoundaries\", ({ enumerable: true, get: function () { return utils_1.checkValuesAgainstBoundaries; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/react-range/lib/types.js\");\nObject.defineProperty(exports, \"Direction\", ({ enumerable: true, get: function () { return types_1.Direction; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0NBQW9DLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCLEdBQUcsMEJBQTBCLEdBQUcsYUFBYTtBQUN2Siw4QkFBOEIsbUJBQU8sQ0FBQyw4REFBUztBQUMvQyxhQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLDhEQUFTO0FBQy9CLHNEQUFxRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNuSSxtREFBa0QsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDN0gsaURBQWdELEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3pILGdFQUErRCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUN2SixjQUFjLG1CQUFPLENBQUMsOERBQVM7QUFDL0IsNkNBQTRDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFzaGJvYXJkLWFwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvaW5kZXguanM/Njc0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllcyA9IGV4cG9ydHMucmVsYXRpdmVWYWx1ZSA9IGV4cG9ydHMudXNlVGh1bWJPdmVybGFwID0gZXhwb3J0cy5EaXJlY3Rpb24gPSBleHBvcnRzLmdldFRyYWNrQmFja2dyb3VuZCA9IGV4cG9ydHMuUmFuZ2UgPSB2b2lkIDA7XG52YXIgUmFuZ2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9SYW5nZVwiKSk7XG5leHBvcnRzLlJhbmdlID0gUmFuZ2VfMS5kZWZhdWx0O1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFRyYWNrQmFja2dyb3VuZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5nZXRUcmFja0JhY2tncm91bmQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1c2VUaHVtYk92ZXJsYXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEudXNlVGh1bWJPdmVybGFwOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVsYXRpdmVWYWx1ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5yZWxhdGl2ZVZhbHVlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5jaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzOyB9IH0pO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpcmVjdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMS5EaXJlY3Rpb247IH0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-range/lib/types.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/types.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Direction = void 0;\nvar Direction;\n(function (Direction) {\n    Direction[\"Right\"] = \"to right\";\n    Direction[\"Left\"] = \"to left\";\n    Direction[\"Down\"] = \"to bottom\";\n    Direction[\"Up\"] = \"to top\";\n})(Direction || (exports.Direction = Direction = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQkFBaUIsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFzaGJvYXJkLWFwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvdHlwZXMuanM/NmUzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGlyZWN0aW9uID0gdm9pZCAwO1xudmFyIERpcmVjdGlvbjtcbihmdW5jdGlvbiAoRGlyZWN0aW9uKSB7XG4gICAgRGlyZWN0aW9uW1wiUmlnaHRcIl0gPSBcInRvIHJpZ2h0XCI7XG4gICAgRGlyZWN0aW9uW1wiTGVmdFwiXSA9IFwidG8gbGVmdFwiO1xuICAgIERpcmVjdGlvbltcIkRvd25cIl0gPSBcInRvIGJvdHRvbVwiO1xuICAgIERpcmVjdGlvbltcIlVwXCJdID0gXCJ0byB0b3BcIjtcbn0pKERpcmVjdGlvbiB8fCAoZXhwb3J0cy5EaXJlY3Rpb24gPSBEaXJlY3Rpb24gPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range/lib/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-range/lib/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/utils.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isIOS = exports.useThumbOverlap = exports.assertUnreachable = exports.voidFn = exports.getTrackBackground = exports.replaceAt = exports.schd = exports.translate = exports.getClosestThumbIndex = exports.translateThumbs = exports.getPaddingAndBorder = exports.getMargin = exports.checkInitialOverlap = exports.checkValuesAgainstBoundaries = exports.checkBoundaries = exports.isVertical = exports.relativeValue = exports.normalizeValue = exports.isStepDivisible = exports.isTouchEvent = exports.getStepDecimals = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/react-range/lib/types.js\");\nvar getStepDecimals = function (step) {\n    var decimals = step.toString().split(\".\")[1];\n    return decimals ? decimals.length : 0;\n};\nexports.getStepDecimals = getStepDecimals;\nfunction isTouchEvent(event) {\n    return ((event.touches && event.touches.length) ||\n        (event.changedTouches && event.changedTouches.length));\n}\nexports.isTouchEvent = isTouchEvent;\nfunction isStepDivisible(min, max, step) {\n    var res = (max - min) / step;\n    var precision = 8;\n    var roundedRes = Number(res.toFixed(precision));\n    return parseInt(roundedRes.toString(), 10) === roundedRes;\n}\nexports.isStepDivisible = isStepDivisible;\nfunction normalizeValue(value, index, min, max, step, allowOverlap, values) {\n    var BIG_NUM = 10e10;\n    value = Math.round(value * BIG_NUM) / BIG_NUM;\n    if (!allowOverlap) {\n        var prev = values[index - 1];\n        var next = values[index + 1];\n        if (prev && prev > value)\n            return prev;\n        if (next && next < value)\n            return next;\n    }\n    if (value > max)\n        return max;\n    if (value < min)\n        return min;\n    // `remainder` is a difference between the given value and a full step value\n    // that is closest lower to the given value and is in the range between the min value\n    // and the given value\n    var remainder = Math.floor(value * BIG_NUM - min * BIG_NUM) % Math.floor(step * BIG_NUM);\n    var closestLowerNum = Math.floor(value * BIG_NUM - Math.abs(remainder));\n    var rounded = remainder === 0 ? value : closestLowerNum / BIG_NUM;\n    // Values with a remainder `< step/2` are rounded to the closest lower value\n    // while values with a remainder `= > step/2` are rounded to the closest bigger value\n    var res = Math.abs(remainder / BIG_NUM) < step / 2 ? rounded : rounded + step;\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    return parseFloat(res.toFixed(decimalPlaces));\n}\nexports.normalizeValue = normalizeValue;\nfunction relativeValue(value, min, max) {\n    return (value - min) / (max - min);\n}\nexports.relativeValue = relativeValue;\nfunction isVertical(direction) {\n    return direction === types_1.Direction.Up || direction === types_1.Direction.Down;\n}\nexports.isVertical = isVertical;\nfunction checkBoundaries(value, min, max) {\n    if (min >= max) {\n        throw new RangeError(\"min (\".concat(min, \") is equal/bigger than max (\").concat(max, \")\"));\n    }\n    if (value < min) {\n        throw new RangeError(\"value (\".concat(value, \") is smaller than min (\").concat(min, \")\"));\n    }\n    if (value > max) {\n        throw new RangeError(\"value (\".concat(value, \") is bigger than max (\").concat(max, \")\"));\n    }\n}\nexports.checkBoundaries = checkBoundaries;\nfunction checkValuesAgainstBoundaries(value, min, max) {\n    if (value < min) {\n        // set selectedValue to min\n        return min;\n    }\n    if (value > max) {\n        // set selectedValue to max\n        return max;\n    }\n    else {\n        return value;\n    }\n}\nexports.checkValuesAgainstBoundaries = checkValuesAgainstBoundaries;\nfunction checkInitialOverlap(values) {\n    if (values.length < 2)\n        return;\n    if (!values.slice(1).every(function (item, i) { return values[i] <= item; })) {\n        throw new RangeError(\"values={[\".concat(values, \"]} needs to be sorted when allowOverlap={false}\"));\n    }\n}\nexports.checkInitialOverlap = checkInitialOverlap;\nfunction getMargin(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style[\"margin-top\"], 10),\n        bottom: parseInt(style[\"margin-bottom\"], 10),\n        left: parseInt(style[\"margin-left\"], 10),\n        right: parseInt(style[\"margin-right\"], 10),\n    };\n}\nexports.getMargin = getMargin;\nfunction getPaddingAndBorder(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style[\"padding-top\"], 10) +\n            parseInt(style[\"border-top-width\"], 10),\n        bottom: parseInt(style[\"padding-bottom\"], 10) +\n            parseInt(style[\"border-bottom-width\"], 10),\n        left: parseInt(style[\"padding-left\"], 10) +\n            parseInt(style[\"border-left-width\"], 10),\n        right: parseInt(style[\"padding-right\"], 10) +\n            parseInt(style[\"border-right-width\"], 10),\n    };\n}\nexports.getPaddingAndBorder = getPaddingAndBorder;\nfunction translateThumbs(elements, offsets, rtl) {\n    var inverter = rtl ? -1 : 1;\n    elements.forEach(function (element, index) {\n        return translate(element, inverter * offsets[index].x, offsets[index].y);\n    });\n}\nexports.translateThumbs = translateThumbs;\n/**\n * Util function for calculating the index of the thumb that is closes to a given position\n * @param thumbs - array of Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getClosestThumbIndex(thumbs, clientX, clientY, direction) {\n    var thumbIndex = 0;\n    var minThumbDistance = getThumbDistance(thumbs[0], clientX, clientY, direction);\n    for (var i = 1; i < thumbs.length; i++) {\n        var thumbDistance = getThumbDistance(thumbs[i], clientX, clientY, direction);\n        if (thumbDistance < minThumbDistance) {\n            minThumbDistance = thumbDistance;\n            thumbIndex = i;\n        }\n    }\n    return thumbIndex;\n}\nexports.getClosestThumbIndex = getClosestThumbIndex;\nfunction translate(element, x, y) {\n    element.style.transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n}\nexports.translate = translate;\n// adapted from https://github.com/alexreardon/raf-schd\nvar schd = function (fn) {\n    var lastArgs = [];\n    var frameId = null;\n    var wrapperFn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        lastArgs = args;\n        if (frameId) {\n            return;\n        }\n        frameId = requestAnimationFrame(function () {\n            frameId = null;\n            fn.apply(void 0, lastArgs);\n        });\n    };\n    return wrapperFn;\n};\nexports.schd = schd;\nfunction replaceAt(values, index, value) {\n    var ret = values.slice(0);\n    ret[index] = value;\n    return ret;\n}\nexports.replaceAt = replaceAt;\nfunction getTrackBackground(_a) {\n    var values = _a.values, colors = _a.colors, min = _a.min, max = _a.max, _b = _a.direction, direction = _b === void 0 ? types_1.Direction.Right : _b, _c = _a.rtl, rtl = _c === void 0 ? false : _c;\n    if (rtl && direction === types_1.Direction.Right) {\n        direction = types_1.Direction.Left;\n    }\n    else if (rtl && types_1.Direction.Left) {\n        direction = types_1.Direction.Right;\n    }\n    // sort values ascending\n    var progress = values\n        .slice(0)\n        .sort(function (a, b) { return a - b; })\n        .map(function (value) { return ((value - min) / (max - min)) * 100; });\n    var middle = progress.reduce(function (acc, point, index) {\n        return \"\".concat(acc, \", \").concat(colors[index], \" \").concat(point, \"%, \").concat(colors[index + 1], \" \").concat(point, \"%\");\n    }, \"\");\n    return \"linear-gradient(\".concat(direction, \", \").concat(colors[0], \" 0%\").concat(middle, \", \").concat(colors[colors.length - 1], \" 100%)\");\n}\nexports.getTrackBackground = getTrackBackground;\nfunction voidFn() { }\nexports.voidFn = voidFn;\nfunction assertUnreachable(x) {\n    throw new Error(\"Didn't expect to get here\");\n}\nexports.assertUnreachable = assertUnreachable;\n/**\n * Util function for grabbing the true largest width of a thumb\n * including the label\n * @param thumbEl - Thumb element to grab the largest width from\n * @param value - Thumb value, not label value\n * @param separator - Label separator value\n */\nvar getThumbWidth = function (thumbEl, value, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var width = Math.ceil(__spreadArray([thumbEl], Array.from(thumbEl.children), true).reduce(function (width, el) {\n        var elWidth = Math.ceil(el.getBoundingClientRect().width);\n        /**\n         * If a label contains a merged label value, it won't return the true\n         * label width for that Thumb. Clone the label and change the value\n         * to that individual Thumb value in order to grab the true width.\n         */\n        if (el.innerText &&\n            el.innerText.includes(separator) &&\n            el.childElementCount === 0) {\n            var elClone = el.cloneNode(true);\n            elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));\n            elClone.style.visibility = \"hidden\";\n            document.body.appendChild(elClone);\n            elWidth = Math.ceil(elClone.getBoundingClientRect().width);\n            document.body.removeChild(elClone);\n        }\n        return elWidth > width ? elWidth : width;\n    }, thumbEl.getBoundingClientRect().width));\n    return width;\n};\n/**\n * Bulk of logic for thumb overlaps\n * Consider a scenario with 5 thumbs;\n * Thumb 1 overlaps with thumb 0 and thumb 2\n * Thumb 2 overlaps with thumb 3\n * We need an array that contains [0, 1, 2, 3]\n * The function needs to return the directly overlapping thumbs\n * and all thumbs overlapping linked to those and so on\n * @param index - Thumb index calculating overlaps for\n * @param offsets - Current Array of Thumb offsets for Range\n * @param thumbs - Array of Thumb elements\n * @param values - Array of Thumb values\n * @param separator - String separator for merged label values\n * @returns overlaps - Array of all overlapping thumbs from the index\n */\nvar getOverlaps = function (index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var overlaps = [];\n    /**\n     * Recursive function for building the overlaps Array\n     * If an overlap is found, find the overlaps for that overlap\n     * @param thumbIndex current Thumb index to find overlaps from\n     */\n    var buildOverlaps = function (thumbIndex) {\n        var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);\n        var thumbX = offsets[thumbIndex].x;\n        /**\n         * Iterate through the Thumb offsets, if there is a match\n         * add the thumbIndex and siblingIndex to the overlaps Array\n         *\n         * Then build overlaps from the overlapping siblingIndex\n         */\n        offsets.forEach(function (_a, siblingIndex) {\n            var siblingX = _a.x;\n            var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);\n            if (thumbIndex !== siblingIndex &&\n                ((thumbX >= siblingX && thumbX <= siblingX + siblingWidth) ||\n                    (thumbX + thumbXWidth >= siblingX &&\n                        thumbX + thumbXWidth <= siblingX + siblingWidth))) {\n                if (!overlaps.includes(siblingIndex)) {\n                    overlaps.push(thumbIndex);\n                    overlaps.push(siblingIndex);\n                    overlaps = __spreadArray(__spreadArray([], overlaps, true), [thumbIndex, siblingIndex], false);\n                    buildOverlaps(siblingIndex);\n                }\n            }\n        });\n    };\n    buildOverlaps(index);\n    // Sort and remove duplicates from the built overlaps\n    return Array.from(new Set(overlaps.sort()));\n};\n/**\n * A custom React Hook for calculating whether a thumb overlaps\n * another and whether labels could/should merge.\n * @param rangeRef - React ref value of Range component\n * @param values - current Range values Array\n * @param index - thumb index\n * @param step - step value, used to calculate the number of decimal places\n * @param separator - string to separate thumb values\n * @returns label value + styling for thumb label\n */\nvar useThumbOverlap = function (rangeRef, values, index, step, separator, valueToLabel) {\n    if (step === void 0) { step = 0.1; }\n    if (separator === void 0) { separator = \" - \"; }\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    // Create initial label style and value. Label value defaults to thumb value\n    var _a = (0, react_1.useState)({}), labelStyle = _a[0], setLabelStyle = _a[1];\n    var _b = (0, react_1.useState)(valueToLabel(values[index].toFixed(decimalPlaces))), labelValue = _b[0], setLabelValue = _b[1];\n    // When the rangeRef or values change, update the Thumb label values and styling\n    (0, react_1.useEffect)(function () {\n        if (rangeRef) {\n            var thumbs = rangeRef.getThumbs();\n            if (thumbs.length < 1)\n                return;\n            var newStyle = {};\n            var offsets_1 = rangeRef.getOffsets();\n            /**\n             * Get any overlaps for the given Thumb index. This must return all linked\n             * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are\n             * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get\n             * 2, 3 and 4 also.\n             */\n            var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel);\n            // Set a default label value of the Thumb value\n            var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));\n            /**\n             * If there are overlaps for the Thumb, we need to calculate the correct\n             * Label value along with the relevant styling. We only want to show a Label\n             * for the left most Thumb in an overlapping set.\n             * All other Thumbs will be set to display: none.\n             */\n            if (overlaps.length) {\n                /**\n                 * Get an Array of the offsets for the overlapping Thumbs\n                 * This is so we can determine if the Thumb we are looking at\n                 * is the left most thumb in an overlapping set\n                 */\n                var offsetsX = overlaps.reduce(function (a, c, i, s) {\n                    return a.length ? __spreadArray(__spreadArray([], a, true), [offsets_1[s[i]].x], false) : [offsets_1[s[i]].x];\n                }, []);\n                /**\n                 * If our Thumb is the left most Thumb, we can build a Label value\n                 * and set the style for that Label\n                 */\n                if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {\n                    /**\n                     * First calculate the Label value. To do this,\n                     * grab all the values for the Thumbs in our overlaps.\n                     * Then convert that to a Set and sort it whilst removing duplicates.\n                     */\n                    var labelValues_1 = [];\n                    overlaps.forEach(function (thumb) {\n                        labelValues_1.push(values[thumb].toFixed(decimalPlaces));\n                    });\n                    /**\n                     *  Update the labelValue with the resulting Array\n                     *  joined by our defined separator\n                     */\n                    labelValue_1 = Array.from(new Set(labelValues_1.sort(function (a, b) { return parseFloat(a) - parseFloat(b); })))\n                        .map(valueToLabel)\n                        .join(separator);\n                    /**\n                     * Lastly, build the label styling. The label styling will\n                     * position the label and apply a transform so that it's centered.\n                     * We want the center point between the left edge of the left most Thumb\n                     * and the right edge of the right most Thumb.\n                     */\n                    var first = Math.min.apply(Math, offsetsX);\n                    var last = Math.max.apply(Math, offsetsX);\n                    var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect()\n                        .width;\n                    newStyle.left = \"\".concat(Math.abs(first - (last + lastWidth)) / 2, \"px\");\n                    newStyle.transform = \"translate(-50%, 0)\";\n                }\n                else {\n                    // If the Thumb isn't the left most Thumb, hide the Label!\n                    newStyle.visibility = \"hidden\";\n                }\n            }\n            // Update the label value and style\n            setLabelValue(labelValue_1);\n            setLabelStyle(newStyle);\n        }\n    }, [rangeRef, values]);\n    return [labelValue, labelStyle];\n};\nexports.useThumbOverlap = useThumbOverlap;\n/**\n * Util function for calculating the distance of the center of a thumb\n * form a given mouse/touch target's position\n * @param thumbEl - Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getThumbDistance(thumbEl, clientX, clientY, direction) {\n    var _a = thumbEl.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;\n    return isVertical(direction)\n        ? Math.abs(clientY - (top + height / 2))\n        : Math.abs(clientX - (left + width / 2));\n}\nvar isIOS = function () {\n    var _a;\n    // @ts-ignore\n    var platform = ((_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.platform) || navigator.platform;\n    return ([\n        \"iPad Simulator\",\n        \"iPhone Simulator\",\n        \"iPod Simulator\",\n        \"iPad\",\n        \"iPhone\",\n        \"iPod\",\n    ].includes(platform) ||\n        // iPad on iOS 13 detection\n        (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document));\n};\nexports.isIOS = isIOS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCLEdBQUcsY0FBYyxHQUFHLDBCQUEwQixHQUFHLGlCQUFpQixHQUFHLFlBQVksR0FBRyxpQkFBaUIsR0FBRyw0QkFBNEIsR0FBRyx1QkFBdUIsR0FBRywyQkFBMkIsR0FBRyxpQkFBaUIsR0FBRywyQkFBMkIsR0FBRyxvQ0FBb0MsR0FBRyx1QkFBdUIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUI7QUFDbmdCLGNBQWMsbUJBQU8sQ0FBQyx3R0FBTztBQUM3QixjQUFjLG1CQUFPLENBQUMsOERBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL2Rhc2hib2FyZC1hcHAvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3V0aWxzLmpzP2E5ZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzSU9TID0gZXhwb3J0cy51c2VUaHVtYk92ZXJsYXAgPSBleHBvcnRzLmFzc2VydFVucmVhY2hhYmxlID0gZXhwb3J0cy52b2lkRm4gPSBleHBvcnRzLmdldFRyYWNrQmFja2dyb3VuZCA9IGV4cG9ydHMucmVwbGFjZUF0ID0gZXhwb3J0cy5zY2hkID0gZXhwb3J0cy50cmFuc2xhdGUgPSBleHBvcnRzLmdldENsb3Nlc3RUaHVtYkluZGV4ID0gZXhwb3J0cy50cmFuc2xhdGVUaHVtYnMgPSBleHBvcnRzLmdldFBhZGRpbmdBbmRCb3JkZXIgPSBleHBvcnRzLmdldE1hcmdpbiA9IGV4cG9ydHMuY2hlY2tJbml0aWFsT3ZlcmxhcCA9IGV4cG9ydHMuY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllcyA9IGV4cG9ydHMuY2hlY2tCb3VuZGFyaWVzID0gZXhwb3J0cy5pc1ZlcnRpY2FsID0gZXhwb3J0cy5yZWxhdGl2ZVZhbHVlID0gZXhwb3J0cy5ub3JtYWxpemVWYWx1ZSA9IGV4cG9ydHMuaXNTdGVwRGl2aXNpYmxlID0gZXhwb3J0cy5pc1RvdWNoRXZlbnQgPSBleHBvcnRzLmdldFN0ZXBEZWNpbWFscyA9IHZvaWQgMDtcbnZhciByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBnZXRTdGVwRGVjaW1hbHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgIHZhciBkZWNpbWFscyA9IHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV07XG4gICAgcmV0dXJuIGRlY2ltYWxzID8gZGVjaW1hbHMubGVuZ3RoIDogMDtcbn07XG5leHBvcnRzLmdldFN0ZXBEZWNpbWFscyA9IGdldFN0ZXBEZWNpbWFscztcbmZ1bmN0aW9uIGlzVG91Y2hFdmVudChldmVudCkge1xuICAgIHJldHVybiAoKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGgpIHx8XG4gICAgICAgIChldmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgpKTtcbn1cbmV4cG9ydHMuaXNUb3VjaEV2ZW50ID0gaXNUb3VjaEV2ZW50O1xuZnVuY3Rpb24gaXNTdGVwRGl2aXNpYmxlKG1pbiwgbWF4LCBzdGVwKSB7XG4gICAgdmFyIHJlcyA9IChtYXggLSBtaW4pIC8gc3RlcDtcbiAgICB2YXIgcHJlY2lzaW9uID0gODtcbiAgICB2YXIgcm91bmRlZFJlcyA9IE51bWJlcihyZXMudG9GaXhlZChwcmVjaXNpb24pKTtcbiAgICByZXR1cm4gcGFyc2VJbnQocm91bmRlZFJlcy50b1N0cmluZygpLCAxMCkgPT09IHJvdW5kZWRSZXM7XG59XG5leHBvcnRzLmlzU3RlcERpdmlzaWJsZSA9IGlzU3RlcERpdmlzaWJsZTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlLCBpbmRleCwgbWluLCBtYXgsIHN0ZXAsIGFsbG93T3ZlcmxhcCwgdmFsdWVzKSB7XG4gICAgdmFyIEJJR19OVU0gPSAxMGUxMDtcbiAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiBCSUdfTlVNKSAvIEJJR19OVU07XG4gICAgaWYgKCFhbGxvd092ZXJsYXApIHtcbiAgICAgICAgdmFyIHByZXYgPSB2YWx1ZXNbaW5kZXggLSAxXTtcbiAgICAgICAgdmFyIG5leHQgPSB2YWx1ZXNbaW5kZXggKyAxXTtcbiAgICAgICAgaWYgKHByZXYgJiYgcHJldiA+IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQgPCB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiBtYXgpXG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgaWYgKHZhbHVlIDwgbWluKVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIC8vIGByZW1haW5kZXJgIGlzIGEgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBnaXZlbiB2YWx1ZSBhbmQgYSBmdWxsIHN0ZXAgdmFsdWVcbiAgICAvLyB0aGF0IGlzIGNsb3Nlc3QgbG93ZXIgdG8gdGhlIGdpdmVuIHZhbHVlIGFuZCBpcyBpbiB0aGUgcmFuZ2UgYmV0d2VlbiB0aGUgbWluIHZhbHVlXG4gICAgLy8gYW5kIHRoZSBnaXZlbiB2YWx1ZVxuICAgIHZhciByZW1haW5kZXIgPSBNYXRoLmZsb29yKHZhbHVlICogQklHX05VTSAtIG1pbiAqIEJJR19OVU0pICUgTWF0aC5mbG9vcihzdGVwICogQklHX05VTSk7XG4gICAgdmFyIGNsb3Nlc3RMb3dlck51bSA9IE1hdGguZmxvb3IodmFsdWUgKiBCSUdfTlVNIC0gTWF0aC5hYnMocmVtYWluZGVyKSk7XG4gICAgdmFyIHJvdW5kZWQgPSByZW1haW5kZXIgPT09IDAgPyB2YWx1ZSA6IGNsb3Nlc3RMb3dlck51bSAvIEJJR19OVU07XG4gICAgLy8gVmFsdWVzIHdpdGggYSByZW1haW5kZXIgYDwgc3RlcC8yYCBhcmUgcm91bmRlZCB0byB0aGUgY2xvc2VzdCBsb3dlciB2YWx1ZVxuICAgIC8vIHdoaWxlIHZhbHVlcyB3aXRoIGEgcmVtYWluZGVyIGA9ID4gc3RlcC8yYCBhcmUgcm91bmRlZCB0byB0aGUgY2xvc2VzdCBiaWdnZXIgdmFsdWVcbiAgICB2YXIgcmVzID0gTWF0aC5hYnMocmVtYWluZGVyIC8gQklHX05VTSkgPCBzdGVwIC8gMiA/IHJvdW5kZWQgOiByb3VuZGVkICsgc3RlcDtcbiAgICB2YXIgZGVjaW1hbFBsYWNlcyA9ICgwLCBleHBvcnRzLmdldFN0ZXBEZWNpbWFscykoc3RlcCk7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocmVzLnRvRml4ZWQoZGVjaW1hbFBsYWNlcykpO1xufVxuZXhwb3J0cy5ub3JtYWxpemVWYWx1ZSA9IG5vcm1hbGl6ZVZhbHVlO1xuZnVuY3Rpb24gcmVsYXRpdmVWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xufVxuZXhwb3J0cy5yZWxhdGl2ZVZhbHVlID0gcmVsYXRpdmVWYWx1ZTtcbmZ1bmN0aW9uIGlzVmVydGljYWwoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uVXAgfHwgZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5Eb3duO1xufVxuZXhwb3J0cy5pc1ZlcnRpY2FsID0gaXNWZXJ0aWNhbDtcbmZ1bmN0aW9uIGNoZWNrQm91bmRhcmllcyh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICBpZiAobWluID49IG1heCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm1pbiAoXCIuY29uY2F0KG1pbiwgXCIpIGlzIGVxdWFsL2JpZ2dlciB0aGFuIG1heCAoXCIpLmNvbmNhdChtYXgsIFwiKVwiKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInZhbHVlIChcIi5jb25jYXQodmFsdWUsIFwiKSBpcyBzbWFsbGVyIHRoYW4gbWluIChcIikuY29uY2F0KG1pbiwgXCIpXCIpKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwidmFsdWUgKFwiLmNvbmNhdCh2YWx1ZSwgXCIpIGlzIGJpZ2dlciB0aGFuIG1heCAoXCIpLmNvbmNhdChtYXgsIFwiKVwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0JvdW5kYXJpZXMgPSBjaGVja0JvdW5kYXJpZXM7XG5mdW5jdGlvbiBjaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAvLyBzZXQgc2VsZWN0ZWRWYWx1ZSB0byBtaW5cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIC8vIHNldCBzZWxlY3RlZFZhbHVlIHRvIG1heFxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllcyA9IGNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXM7XG5mdW5jdGlvbiBjaGVja0luaXRpYWxPdmVybGFwKHZhbHVlcykge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoIDwgMilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghdmFsdWVzLnNsaWNlKDEpLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpKSB7IHJldHVybiB2YWx1ZXNbaV0gPD0gaXRlbTsgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ2YWx1ZXM9e1tcIi5jb25jYXQodmFsdWVzLCBcIl19IG5lZWRzIHRvIGJlIHNvcnRlZCB3aGVuIGFsbG93T3ZlcmxhcD17ZmFsc2V9XCIpKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrSW5pdGlhbE92ZXJsYXAgPSBjaGVja0luaXRpYWxPdmVybGFwO1xuZnVuY3Rpb24gZ2V0TWFyZ2luKGVsZW1lbnQpIHtcbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHBhcnNlSW50KHN0eWxlW1wibWFyZ2luLXRvcFwiXSwgMTApLFxuICAgICAgICBib3R0b206IHBhcnNlSW50KHN0eWxlW1wibWFyZ2luLWJvdHRvbVwiXSwgMTApLFxuICAgICAgICBsZWZ0OiBwYXJzZUludChzdHlsZVtcIm1hcmdpbi1sZWZ0XCJdLCAxMCksXG4gICAgICAgIHJpZ2h0OiBwYXJzZUludChzdHlsZVtcIm1hcmdpbi1yaWdodFwiXSwgMTApLFxuICAgIH07XG59XG5leHBvcnRzLmdldE1hcmdpbiA9IGdldE1hcmdpbjtcbmZ1bmN0aW9uIGdldFBhZGRpbmdBbmRCb3JkZXIoZWxlbWVudCkge1xuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcGFyc2VJbnQoc3R5bGVbXCJwYWRkaW5nLXRvcFwiXSwgMTApICtcbiAgICAgICAgICAgIHBhcnNlSW50KHN0eWxlW1wiYm9yZGVyLXRvcC13aWR0aFwiXSwgMTApLFxuICAgICAgICBib3R0b206IHBhcnNlSW50KHN0eWxlW1wicGFkZGluZy1ib3R0b21cIl0sIDEwKSArXG4gICAgICAgICAgICBwYXJzZUludChzdHlsZVtcImJvcmRlci1ib3R0b20td2lkdGhcIl0sIDEwKSxcbiAgICAgICAgbGVmdDogcGFyc2VJbnQoc3R5bGVbXCJwYWRkaW5nLWxlZnRcIl0sIDEwKSArXG4gICAgICAgICAgICBwYXJzZUludChzdHlsZVtcImJvcmRlci1sZWZ0LXdpZHRoXCJdLCAxMCksXG4gICAgICAgIHJpZ2h0OiBwYXJzZUludChzdHlsZVtcInBhZGRpbmctcmlnaHRcIl0sIDEwKSArXG4gICAgICAgICAgICBwYXJzZUludChzdHlsZVtcImJvcmRlci1yaWdodC13aWR0aFwiXSwgMTApLFxuICAgIH07XG59XG5leHBvcnRzLmdldFBhZGRpbmdBbmRCb3JkZXIgPSBnZXRQYWRkaW5nQW5kQm9yZGVyO1xuZnVuY3Rpb24gdHJhbnNsYXRlVGh1bWJzKGVsZW1lbnRzLCBvZmZzZXRzLCBydGwpIHtcbiAgICB2YXIgaW52ZXJ0ZXIgPSBydGwgPyAtMSA6IDE7XG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZShlbGVtZW50LCBpbnZlcnRlciAqIG9mZnNldHNbaW5kZXhdLngsIG9mZnNldHNbaW5kZXhdLnkpO1xuICAgIH0pO1xufVxuZXhwb3J0cy50cmFuc2xhdGVUaHVtYnMgPSB0cmFuc2xhdGVUaHVtYnM7XG4vKipcbiAqIFV0aWwgZnVuY3Rpb24gZm9yIGNhbGN1bGF0aW5nIHRoZSBpbmRleCBvZiB0aGUgdGh1bWIgdGhhdCBpcyBjbG9zZXMgdG8gYSBnaXZlbiBwb3NpdGlvblxuICogQHBhcmFtIHRodW1icyAtIGFycmF5IG9mIFRodW1iIGVsZW1lbnQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tXG4gKiBAcGFyYW0gY2xpZW50WCAtIHRhcmdldCB4IHBvc2l0aW9uIChtb3VzZS90b3VjaClcbiAqIEBwYXJhbSBjbGllbnRZIC0gdGFyZ2V0IHkgcG9zaXRpb24gKG1vdXNlL3RvdWNoKVxuICogQHBhcmFtIGRpcmVjdGlvbiAtIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHRyYWNrXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RUaHVtYkluZGV4KHRodW1icywgY2xpZW50WCwgY2xpZW50WSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIHRodW1iSW5kZXggPSAwO1xuICAgIHZhciBtaW5UaHVtYkRpc3RhbmNlID0gZ2V0VGh1bWJEaXN0YW5jZSh0aHVtYnNbMF0sIGNsaWVudFgsIGNsaWVudFksIGRpcmVjdGlvbik7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aHVtYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRodW1iRGlzdGFuY2UgPSBnZXRUaHVtYkRpc3RhbmNlKHRodW1ic1tpXSwgY2xpZW50WCwgY2xpZW50WSwgZGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKHRodW1iRGlzdGFuY2UgPCBtaW5UaHVtYkRpc3RhbmNlKSB7XG4gICAgICAgICAgICBtaW5UaHVtYkRpc3RhbmNlID0gdGh1bWJEaXN0YW5jZTtcbiAgICAgICAgICAgIHRodW1iSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aHVtYkluZGV4O1xufVxuZXhwb3J0cy5nZXRDbG9zZXN0VGh1bWJJbmRleCA9IGdldENsb3Nlc3RUaHVtYkluZGV4O1xuZnVuY3Rpb24gdHJhbnNsYXRlKGVsZW1lbnQsIHgsIHkpIHtcbiAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh4LCBcInB4LCBcIikuY29uY2F0KHksIFwicHgpXCIpO1xufVxuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FsZXhyZWFyZG9uL3JhZi1zY2hkXG52YXIgc2NoZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBsYXN0QXJncyA9IFtdO1xuICAgIHZhciBmcmFtZUlkID0gbnVsbDtcbiAgICB2YXIgd3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gYXJncztcbiAgICAgICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgICAgICAgICAgZm4uYXBwbHkodm9pZCAwLCBsYXN0QXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHdyYXBwZXJGbjtcbn07XG5leHBvcnRzLnNjaGQgPSBzY2hkO1xuZnVuY3Rpb24gcmVwbGFjZUF0KHZhbHVlcywgaW5kZXgsIHZhbHVlKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlcy5zbGljZSgwKTtcbiAgICByZXRbaW5kZXhdID0gdmFsdWU7XG4gICAgcmV0dXJuIHJldDtcbn1cbmV4cG9ydHMucmVwbGFjZUF0ID0gcmVwbGFjZUF0O1xuZnVuY3Rpb24gZ2V0VHJhY2tCYWNrZ3JvdW5kKF9hKSB7XG4gICAgdmFyIHZhbHVlcyA9IF9hLnZhbHVlcywgY29sb3JzID0gX2EuY29sb3JzLCBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heCwgX2IgPSBfYS5kaXJlY3Rpb24sIGRpcmVjdGlvbiA9IF9iID09PSB2b2lkIDAgPyB0eXBlc18xLkRpcmVjdGlvbi5SaWdodCA6IF9iLCBfYyA9IF9hLnJ0bCwgcnRsID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2M7XG4gICAgaWYgKHJ0bCAmJiBkaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0KSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJ0bCAmJiB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0KSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0O1xuICAgIH1cbiAgICAvLyBzb3J0IHZhbHVlcyBhc2NlbmRpbmdcbiAgICB2YXIgcHJvZ3Jlc3MgPSB2YWx1ZXNcbiAgICAgICAgLnNsaWNlKDApXG4gICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICgodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbikpICogMTAwOyB9KTtcbiAgICB2YXIgbWlkZGxlID0gcHJvZ3Jlc3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBvaW50LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoYWNjLCBcIiwgXCIpLmNvbmNhdChjb2xvcnNbaW5kZXhdLCBcIiBcIikuY29uY2F0KHBvaW50LCBcIiUsIFwiKS5jb25jYXQoY29sb3JzW2luZGV4ICsgMV0sIFwiIFwiKS5jb25jYXQocG9pbnQsIFwiJVwiKTtcbiAgICB9LCBcIlwiKTtcbiAgICByZXR1cm4gXCJsaW5lYXItZ3JhZGllbnQoXCIuY29uY2F0KGRpcmVjdGlvbiwgXCIsIFwiKS5jb25jYXQoY29sb3JzWzBdLCBcIiAwJVwiKS5jb25jYXQobWlkZGxlLCBcIiwgXCIpLmNvbmNhdChjb2xvcnNbY29sb3JzLmxlbmd0aCAtIDFdLCBcIiAxMDAlKVwiKTtcbn1cbmV4cG9ydHMuZ2V0VHJhY2tCYWNrZ3JvdW5kID0gZ2V0VHJhY2tCYWNrZ3JvdW5kO1xuZnVuY3Rpb24gdm9pZEZuKCkgeyB9XG5leHBvcnRzLnZvaWRGbiA9IHZvaWRGbjtcbmZ1bmN0aW9uIGFzc2VydFVucmVhY2hhYmxlKHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWRuJ3QgZXhwZWN0IHRvIGdldCBoZXJlXCIpO1xufVxuZXhwb3J0cy5hc3NlcnRVbnJlYWNoYWJsZSA9IGFzc2VydFVucmVhY2hhYmxlO1xuLyoqXG4gKiBVdGlsIGZ1bmN0aW9uIGZvciBncmFiYmluZyB0aGUgdHJ1ZSBsYXJnZXN0IHdpZHRoIG9mIGEgdGh1bWJcbiAqIGluY2x1ZGluZyB0aGUgbGFiZWxcbiAqIEBwYXJhbSB0aHVtYkVsIC0gVGh1bWIgZWxlbWVudCB0byBncmFiIHRoZSBsYXJnZXN0IHdpZHRoIGZyb21cbiAqIEBwYXJhbSB2YWx1ZSAtIFRodW1iIHZhbHVlLCBub3QgbGFiZWwgdmFsdWVcbiAqIEBwYXJhbSBzZXBhcmF0b3IgLSBMYWJlbCBzZXBhcmF0b3IgdmFsdWVcbiAqL1xudmFyIGdldFRodW1iV2lkdGggPSBmdW5jdGlvbiAodGh1bWJFbCwgdmFsdWUsIHNlcGFyYXRvciwgZGVjaW1hbFBsYWNlcywgdmFsdWVUb0xhYmVsKSB7XG4gICAgaWYgKHZhbHVlVG9MYWJlbCA9PT0gdm9pZCAwKSB7IHZhbHVlVG9MYWJlbCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07IH1cbiAgICB2YXIgd2lkdGggPSBNYXRoLmNlaWwoX19zcHJlYWRBcnJheShbdGh1bWJFbF0sIEFycmF5LmZyb20odGh1bWJFbC5jaGlsZHJlbiksIHRydWUpLnJlZHVjZShmdW5jdGlvbiAod2lkdGgsIGVsKSB7XG4gICAgICAgIHZhciBlbFdpZHRoID0gTWF0aC5jZWlsKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgbGFiZWwgY29udGFpbnMgYSBtZXJnZWQgbGFiZWwgdmFsdWUsIGl0IHdvbid0IHJldHVybiB0aGUgdHJ1ZVxuICAgICAgICAgKiBsYWJlbCB3aWR0aCBmb3IgdGhhdCBUaHVtYi4gQ2xvbmUgdGhlIGxhYmVsIGFuZCBjaGFuZ2UgdGhlIHZhbHVlXG4gICAgICAgICAqIHRvIHRoYXQgaW5kaXZpZHVhbCBUaHVtYiB2YWx1ZSBpbiBvcmRlciB0byBncmFiIHRoZSB0cnVlIHdpZHRoLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGVsLmlubmVyVGV4dCAmJlxuICAgICAgICAgICAgZWwuaW5uZXJUZXh0LmluY2x1ZGVzKHNlcGFyYXRvcikgJiZcbiAgICAgICAgICAgIGVsLmNoaWxkRWxlbWVudENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgZWxDbG9uZSA9IGVsLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgIGVsQ2xvbmUuaW5uZXJIVE1MID0gdmFsdWVUb0xhYmVsKHZhbHVlLnRvRml4ZWQoZGVjaW1hbFBsYWNlcykpO1xuICAgICAgICAgICAgZWxDbG9uZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxDbG9uZSk7XG4gICAgICAgICAgICBlbFdpZHRoID0gTWF0aC5jZWlsKGVsQ2xvbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbENsb25lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxXaWR0aCA+IHdpZHRoID8gZWxXaWR0aCA6IHdpZHRoO1xuICAgIH0sIHRodW1iRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpKTtcbiAgICByZXR1cm4gd2lkdGg7XG59O1xuLyoqXG4gKiBCdWxrIG9mIGxvZ2ljIGZvciB0aHVtYiBvdmVybGFwc1xuICogQ29uc2lkZXIgYSBzY2VuYXJpbyB3aXRoIDUgdGh1bWJzO1xuICogVGh1bWIgMSBvdmVybGFwcyB3aXRoIHRodW1iIDAgYW5kIHRodW1iIDJcbiAqIFRodW1iIDIgb3ZlcmxhcHMgd2l0aCB0aHVtYiAzXG4gKiBXZSBuZWVkIGFuIGFycmF5IHRoYXQgY29udGFpbnMgWzAsIDEsIDIsIDNdXG4gKiBUaGUgZnVuY3Rpb24gbmVlZHMgdG8gcmV0dXJuIHRoZSBkaXJlY3RseSBvdmVybGFwcGluZyB0aHVtYnNcbiAqIGFuZCBhbGwgdGh1bWJzIG92ZXJsYXBwaW5nIGxpbmtlZCB0byB0aG9zZSBhbmQgc28gb25cbiAqIEBwYXJhbSBpbmRleCAtIFRodW1iIGluZGV4IGNhbGN1bGF0aW5nIG92ZXJsYXBzIGZvclxuICogQHBhcmFtIG9mZnNldHMgLSBDdXJyZW50IEFycmF5IG9mIFRodW1iIG9mZnNldHMgZm9yIFJhbmdlXG4gKiBAcGFyYW0gdGh1bWJzIC0gQXJyYXkgb2YgVGh1bWIgZWxlbWVudHNcbiAqIEBwYXJhbSB2YWx1ZXMgLSBBcnJheSBvZiBUaHVtYiB2YWx1ZXNcbiAqIEBwYXJhbSBzZXBhcmF0b3IgLSBTdHJpbmcgc2VwYXJhdG9yIGZvciBtZXJnZWQgbGFiZWwgdmFsdWVzXG4gKiBAcmV0dXJucyBvdmVybGFwcyAtIEFycmF5IG9mIGFsbCBvdmVybGFwcGluZyB0aHVtYnMgZnJvbSB0aGUgaW5kZXhcbiAqL1xudmFyIGdldE92ZXJsYXBzID0gZnVuY3Rpb24gKGluZGV4LCBvZmZzZXRzLCB0aHVtYnMsIHZhbHVlcywgc2VwYXJhdG9yLCBkZWNpbWFsUGxhY2VzLCB2YWx1ZVRvTGFiZWwpIHtcbiAgICBpZiAodmFsdWVUb0xhYmVsID09PSB2b2lkIDApIHsgdmFsdWVUb0xhYmVsID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTsgfVxuICAgIHZhciBvdmVybGFwcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZSBmdW5jdGlvbiBmb3IgYnVpbGRpbmcgdGhlIG92ZXJsYXBzIEFycmF5XG4gICAgICogSWYgYW4gb3ZlcmxhcCBpcyBmb3VuZCwgZmluZCB0aGUgb3ZlcmxhcHMgZm9yIHRoYXQgb3ZlcmxhcFxuICAgICAqIEBwYXJhbSB0aHVtYkluZGV4IGN1cnJlbnQgVGh1bWIgaW5kZXggdG8gZmluZCBvdmVybGFwcyBmcm9tXG4gICAgICovXG4gICAgdmFyIGJ1aWxkT3ZlcmxhcHMgPSBmdW5jdGlvbiAodGh1bWJJbmRleCkge1xuICAgICAgICB2YXIgdGh1bWJYV2lkdGggPSBnZXRUaHVtYldpZHRoKHRodW1ic1t0aHVtYkluZGV4XSwgdmFsdWVzW3RodW1iSW5kZXhdLCBzZXBhcmF0b3IsIGRlY2ltYWxQbGFjZXMsIHZhbHVlVG9MYWJlbCk7XG4gICAgICAgIHZhciB0aHVtYlggPSBvZmZzZXRzW3RodW1iSW5kZXhdLng7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIHRocm91Z2ggdGhlIFRodW1iIG9mZnNldHMsIGlmIHRoZXJlIGlzIGEgbWF0Y2hcbiAgICAgICAgICogYWRkIHRoZSB0aHVtYkluZGV4IGFuZCBzaWJsaW5nSW5kZXggdG8gdGhlIG92ZXJsYXBzIEFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZW4gYnVpbGQgb3ZlcmxhcHMgZnJvbSB0aGUgb3ZlcmxhcHBpbmcgc2libGluZ0luZGV4XG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXRzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBzaWJsaW5nSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzaWJsaW5nWCA9IF9hLng7XG4gICAgICAgICAgICB2YXIgc2libGluZ1dpZHRoID0gZ2V0VGh1bWJXaWR0aCh0aHVtYnNbc2libGluZ0luZGV4XSwgdmFsdWVzW3NpYmxpbmdJbmRleF0sIHNlcGFyYXRvciwgZGVjaW1hbFBsYWNlcywgdmFsdWVUb0xhYmVsKTtcbiAgICAgICAgICAgIGlmICh0aHVtYkluZGV4ICE9PSBzaWJsaW5nSW5kZXggJiZcbiAgICAgICAgICAgICAgICAoKHRodW1iWCA+PSBzaWJsaW5nWCAmJiB0aHVtYlggPD0gc2libGluZ1ggKyBzaWJsaW5nV2lkdGgpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aHVtYlggKyB0aHVtYlhXaWR0aCA+PSBzaWJsaW5nWCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJYICsgdGh1bWJYV2lkdGggPD0gc2libGluZ1ggKyBzaWJsaW5nV2lkdGgpKSkge1xuICAgICAgICAgICAgICAgIGlmICghb3ZlcmxhcHMuaW5jbHVkZXMoc2libGluZ0luZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcy5wdXNoKHRodW1iSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcy5wdXNoKHNpYmxpbmdJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBvdmVybGFwcywgdHJ1ZSksIFt0aHVtYkluZGV4LCBzaWJsaW5nSW5kZXhdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkT3ZlcmxhcHMoc2libGluZ0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYnVpbGRPdmVybGFwcyhpbmRleCk7XG4gICAgLy8gU29ydCBhbmQgcmVtb3ZlIGR1cGxpY2F0ZXMgZnJvbSB0aGUgYnVpbHQgb3ZlcmxhcHNcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KG92ZXJsYXBzLnNvcnQoKSkpO1xufTtcbi8qKlxuICogQSBjdXN0b20gUmVhY3QgSG9vayBmb3IgY2FsY3VsYXRpbmcgd2hldGhlciBhIHRodW1iIG92ZXJsYXBzXG4gKiBhbm90aGVyIGFuZCB3aGV0aGVyIGxhYmVscyBjb3VsZC9zaG91bGQgbWVyZ2UuXG4gKiBAcGFyYW0gcmFuZ2VSZWYgLSBSZWFjdCByZWYgdmFsdWUgb2YgUmFuZ2UgY29tcG9uZW50XG4gKiBAcGFyYW0gdmFsdWVzIC0gY3VycmVudCBSYW5nZSB2YWx1ZXMgQXJyYXlcbiAqIEBwYXJhbSBpbmRleCAtIHRodW1iIGluZGV4XG4gKiBAcGFyYW0gc3RlcCAtIHN0ZXAgdmFsdWUsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAqIEBwYXJhbSBzZXBhcmF0b3IgLSBzdHJpbmcgdG8gc2VwYXJhdGUgdGh1bWIgdmFsdWVzXG4gKiBAcmV0dXJucyBsYWJlbCB2YWx1ZSArIHN0eWxpbmcgZm9yIHRodW1iIGxhYmVsXG4gKi9cbnZhciB1c2VUaHVtYk92ZXJsYXAgPSBmdW5jdGlvbiAocmFuZ2VSZWYsIHZhbHVlcywgaW5kZXgsIHN0ZXAsIHNlcGFyYXRvciwgdmFsdWVUb0xhYmVsKSB7XG4gICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkgeyBzdGVwID0gMC4xOyB9XG4gICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwKSB7IHNlcGFyYXRvciA9IFwiIC0gXCI7IH1cbiAgICBpZiAodmFsdWVUb0xhYmVsID09PSB2b2lkIDApIHsgdmFsdWVUb0xhYmVsID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTsgfVxuICAgIHZhciBkZWNpbWFsUGxhY2VzID0gKDAsIGV4cG9ydHMuZ2V0U3RlcERlY2ltYWxzKShzdGVwKTtcbiAgICAvLyBDcmVhdGUgaW5pdGlhbCBsYWJlbCBzdHlsZSBhbmQgdmFsdWUuIExhYmVsIHZhbHVlIGRlZmF1bHRzIHRvIHRodW1iIHZhbHVlXG4gICAgdmFyIF9hID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKHt9KSwgbGFiZWxTdHlsZSA9IF9hWzBdLCBzZXRMYWJlbFN0eWxlID0gX2FbMV07XG4gICAgdmFyIF9iID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKHZhbHVlVG9MYWJlbCh2YWx1ZXNbaW5kZXhdLnRvRml4ZWQoZGVjaW1hbFBsYWNlcykpKSwgbGFiZWxWYWx1ZSA9IF9iWzBdLCBzZXRMYWJlbFZhbHVlID0gX2JbMV07XG4gICAgLy8gV2hlbiB0aGUgcmFuZ2VSZWYgb3IgdmFsdWVzIGNoYW5nZSwgdXBkYXRlIHRoZSBUaHVtYiBsYWJlbCB2YWx1ZXMgYW5kIHN0eWxpbmdcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJhbmdlUmVmKSB7XG4gICAgICAgICAgICB2YXIgdGh1bWJzID0gcmFuZ2VSZWYuZ2V0VGh1bWJzKCk7XG4gICAgICAgICAgICBpZiAodGh1bWJzLmxlbmd0aCA8IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG5ld1N0eWxlID0ge307XG4gICAgICAgICAgICB2YXIgb2Zmc2V0c18xID0gcmFuZ2VSZWYuZ2V0T2Zmc2V0cygpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYW55IG92ZXJsYXBzIGZvciB0aGUgZ2l2ZW4gVGh1bWIgaW5kZXguIFRoaXMgbXVzdCByZXR1cm4gYWxsIGxpbmtlZFxuICAgICAgICAgICAgICogVGh1bWJzLiBTbyBpZiB0aGVyZSBhcmUgNCBUaHVtYnMgYW5kIFRodW1icyAyLCAzIGFuZCA0IG92ZXJsYXAuIElmIHdlIGFyZVxuICAgICAgICAgICAgICogZ2V0dGluZyB0aGUgb3ZlcmxhcHMgZm9yIFRodW1iIDEgYW5kIGl0IG92ZXJsYXBzIG9ubHkgVGh1bWIgMiwgd2UgbXVzdCBnZXRcbiAgICAgICAgICAgICAqIDIsIDMgYW5kIDQgYWxzby5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIG92ZXJsYXBzID0gZ2V0T3ZlcmxhcHMoaW5kZXgsIG9mZnNldHNfMSwgdGh1bWJzLCB2YWx1ZXMsIHNlcGFyYXRvciwgZGVjaW1hbFBsYWNlcywgdmFsdWVUb0xhYmVsKTtcbiAgICAgICAgICAgIC8vIFNldCBhIGRlZmF1bHQgbGFiZWwgdmFsdWUgb2YgdGhlIFRodW1iIHZhbHVlXG4gICAgICAgICAgICB2YXIgbGFiZWxWYWx1ZV8xID0gdmFsdWVUb0xhYmVsKHZhbHVlc1tpbmRleF0udG9GaXhlZChkZWNpbWFsUGxhY2VzKSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZXJlIGFyZSBvdmVybGFwcyBmb3IgdGhlIFRodW1iLCB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdFxuICAgICAgICAgICAgICogTGFiZWwgdmFsdWUgYWxvbmcgd2l0aCB0aGUgcmVsZXZhbnQgc3R5bGluZy4gV2Ugb25seSB3YW50IHRvIHNob3cgYSBMYWJlbFxuICAgICAgICAgICAgICogZm9yIHRoZSBsZWZ0IG1vc3QgVGh1bWIgaW4gYW4gb3ZlcmxhcHBpbmcgc2V0LlxuICAgICAgICAgICAgICogQWxsIG90aGVyIFRodW1icyB3aWxsIGJlIHNldCB0byBkaXNwbGF5OiBub25lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAob3ZlcmxhcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogR2V0IGFuIEFycmF5IG9mIHRoZSBvZmZzZXRzIGZvciB0aGUgb3ZlcmxhcHBpbmcgVGh1bWJzXG4gICAgICAgICAgICAgICAgICogVGhpcyBpcyBzbyB3ZSBjYW4gZGV0ZXJtaW5lIGlmIHRoZSBUaHVtYiB3ZSBhcmUgbG9va2luZyBhdFxuICAgICAgICAgICAgICAgICAqIGlzIHRoZSBsZWZ0IG1vc3QgdGh1bWIgaW4gYW4gb3ZlcmxhcHBpbmcgc2V0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldHNYID0gb3ZlcmxhcHMucmVkdWNlKGZ1bmN0aW9uIChhLCBjLCBpLCBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA/IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgYSwgdHJ1ZSksIFtvZmZzZXRzXzFbc1tpXV0ueF0sIGZhbHNlKSA6IFtvZmZzZXRzXzFbc1tpXV0ueF07XG4gICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIG91ciBUaHVtYiBpcyB0aGUgbGVmdCBtb3N0IFRodW1iLCB3ZSBjYW4gYnVpbGQgYSBMYWJlbCB2YWx1ZVxuICAgICAgICAgICAgICAgICAqIGFuZCBzZXQgdGhlIHN0eWxlIGZvciB0aGF0IExhYmVsXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgubWluLmFwcGx5KE1hdGgsIG9mZnNldHNYKSA9PT0gb2Zmc2V0c18xW2luZGV4XS54KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBGaXJzdCBjYWxjdWxhdGUgdGhlIExhYmVsIHZhbHVlLiBUbyBkbyB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgKiBncmFiIGFsbCB0aGUgdmFsdWVzIGZvciB0aGUgVGh1bWJzIGluIG91ciBvdmVybGFwcy5cbiAgICAgICAgICAgICAgICAgICAgICogVGhlbiBjb252ZXJ0IHRoYXQgdG8gYSBTZXQgYW5kIHNvcnQgaXQgd2hpbHN0IHJlbW92aW5nIGR1cGxpY2F0ZXMuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxWYWx1ZXNfMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcy5mb3JFYWNoKGZ1bmN0aW9uICh0aHVtYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxWYWx1ZXNfMS5wdXNoKHZhbHVlc1t0aHVtYl0udG9GaXhlZChkZWNpbWFsUGxhY2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogIFVwZGF0ZSB0aGUgbGFiZWxWYWx1ZSB3aXRoIHRoZSByZXN1bHRpbmcgQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICogIGpvaW5lZCBieSBvdXIgZGVmaW5lZCBzZXBhcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsVmFsdWVfMSA9IEFycmF5LmZyb20obmV3IFNldChsYWJlbFZhbHVlc18xLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHBhcnNlRmxvYXQoYSkgLSBwYXJzZUZsb2F0KGIpOyB9KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKHZhbHVlVG9MYWJlbClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBMYXN0bHksIGJ1aWxkIHRoZSBsYWJlbCBzdHlsaW5nLiBUaGUgbGFiZWwgc3R5bGluZyB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAqIHBvc2l0aW9uIHRoZSBsYWJlbCBhbmQgYXBwbHkgYSB0cmFuc2Zvcm0gc28gdGhhdCBpdCdzIGNlbnRlcmVkLlxuICAgICAgICAgICAgICAgICAgICAgKiBXZSB3YW50IHRoZSBjZW50ZXIgcG9pbnQgYmV0d2VlbiB0aGUgbGVmdCBlZGdlIG9mIHRoZSBsZWZ0IG1vc3QgVGh1bWJcbiAgICAgICAgICAgICAgICAgICAgICogYW5kIHRoZSByaWdodCBlZGdlIG9mIHRoZSByaWdodCBtb3N0IFRodW1iLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgb2Zmc2V0c1gpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIG9mZnNldHNYKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RXaWR0aCA9IHRodW1ic1tvdmVybGFwc1tvZmZzZXRzWC5pbmRleE9mKGxhc3QpXV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KE1hdGguYWJzKGZpcnN0IC0gKGxhc3QgKyBsYXN0V2lkdGgpKSAvIDIsIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKC01MCUsIDApXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgVGh1bWIgaXNuJ3QgdGhlIGxlZnQgbW9zdCBUaHVtYiwgaGlkZSB0aGUgTGFiZWwhXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFiZWwgdmFsdWUgYW5kIHN0eWxlXG4gICAgICAgICAgICBzZXRMYWJlbFZhbHVlKGxhYmVsVmFsdWVfMSk7XG4gICAgICAgICAgICBzZXRMYWJlbFN0eWxlKG5ld1N0eWxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtyYW5nZVJlZiwgdmFsdWVzXSk7XG4gICAgcmV0dXJuIFtsYWJlbFZhbHVlLCBsYWJlbFN0eWxlXTtcbn07XG5leHBvcnRzLnVzZVRodW1iT3ZlcmxhcCA9IHVzZVRodW1iT3ZlcmxhcDtcbi8qKlxuICogVXRpbCBmdW5jdGlvbiBmb3IgY2FsY3VsYXRpbmcgdGhlIGRpc3RhbmNlIG9mIHRoZSBjZW50ZXIgb2YgYSB0aHVtYlxuICogZm9ybSBhIGdpdmVuIG1vdXNlL3RvdWNoIHRhcmdldCdzIHBvc2l0aW9uXG4gKiBAcGFyYW0gdGh1bWJFbCAtIFRodW1iIGVsZW1lbnQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tXG4gKiBAcGFyYW0gY2xpZW50WCAtIHRhcmdldCB4IHBvc2l0aW9uIChtb3VzZS90b3VjaClcbiAqIEBwYXJhbSBjbGllbnRZIC0gdGFyZ2V0IHkgcG9zaXRpb24gKG1vdXNlL3RvdWNoKVxuICogQHBhcmFtIGRpcmVjdGlvbiAtIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHRyYWNrXG4gKi9cbmZ1bmN0aW9uIGdldFRodW1iRGlzdGFuY2UodGh1bWJFbCwgY2xpZW50WCwgY2xpZW50WSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIF9hID0gdGh1bWJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbGVmdCA9IF9hLmxlZnQsIHRvcCA9IF9hLnRvcCwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgIHJldHVybiBpc1ZlcnRpY2FsKGRpcmVjdGlvbilcbiAgICAgICAgPyBNYXRoLmFicyhjbGllbnRZIC0gKHRvcCArIGhlaWdodCAvIDIpKVxuICAgICAgICA6IE1hdGguYWJzKGNsaWVudFggLSAobGVmdCArIHdpZHRoIC8gMikpO1xufVxudmFyIGlzSU9TID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFyIHBsYXRmb3JtID0gKChfYSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGxhdGZvcm0pIHx8IG5hdmlnYXRvci5wbGF0Zm9ybTtcbiAgICByZXR1cm4gKFtcbiAgICAgICAgXCJpUGFkIFNpbXVsYXRvclwiLFxuICAgICAgICBcImlQaG9uZSBTaW11bGF0b3JcIixcbiAgICAgICAgXCJpUG9kIFNpbXVsYXRvclwiLFxuICAgICAgICBcImlQYWRcIixcbiAgICAgICAgXCJpUGhvbmVcIixcbiAgICAgICAgXCJpUG9kXCIsXG4gICAgXS5pbmNsdWRlcyhwbGF0Zm9ybSkgfHxcbiAgICAgICAgLy8gaVBhZCBvbiBpT1MgMTMgZGV0ZWN0aW9uXG4gICAgICAgIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTWFjXCIpICYmIFwib250b3VjaGVuZFwiIGluIGRvY3VtZW50KSk7XG59O1xuZXhwb3J0cy5pc0lPUyA9IGlzSU9TO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range/lib/utils.js\n");

/***/ })

};
;